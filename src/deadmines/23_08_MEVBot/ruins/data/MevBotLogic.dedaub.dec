// Decompiled by library.dedaub.com
// 2023.07.27 07:44 UTC
// Compiled using the solidity compiler version 0.8.7


// Data structures and variables inferred from the use of storage instructions
mapping (uint256 => uint256) _borrow; // STORAGE[0x1]
uint256 _refund; // STORAGE[0x2]
uint256 _owner; // STORAGE[0x0] bytes 0 to 19



function 0x1970(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { 
    CALLDATACOPY(v0.data, varg1, varg0);
    MEM[varg0 + v0.data] = 0;
    require(_refund == keccak256(v0.data), Error('BBVault: STATUS'));
    v1 = varg1 + varg0;
    require(v1 - varg1 >= 32);
    require(msg.data[varg1] <= 0xffffffffffffffff);
    v2 = varg1 + msg.data[varg1];
    require(v1 - v2 >= 288);
    v3 = MEM[64];
    require(!((v3 + 288 < v3) | (v3 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v3 + 288;
    require(msg.data[v2] == address(msg.data[v2]));
    require(msg.data[v2 + 32] == address(msg.data[v2 + 32]));
    require(msg.data[v2 + 64] == address(msg.data[v2 + 64]));
    require(msg.data[v2 + 192] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 192] + 31 < v1);
    v4 = 0x3867(msg.data[v2 + msg.data[v2 + 192]]);
    require(!((MEM[64] + (~0x1f & v4 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v4 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v4 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 192]];
    v5 = v6 = MEM[64] + 32;
    v7 = v8 = v2 + msg.data[v2 + 192] + 32;
    require(v2 + msg.data[v2 + 192] + (msg.data[v2 + msg.data[v2 + 192]] << 5) + 32 <= v1);
    v9 = v10 = 0;
    while (v9 < msg.data[v2 + msg.data[v2 + 192]]) {
        MEM[v5] = msg.data[v7];
        v5 += 32;
        v7 += 32;
        v9 += 1;
    }
    require(msg.data[v2 + 224] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 224] + 31 < v1);
    v11 = 0x3867(msg.data[v2 + msg.data[v2 + 224]]);
    require(!((MEM[64] + (~0x1f & v11 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v11 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v11 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 224]];
    v12 = v13 = MEM[64] + 32;
    v14 = v15 = v2 + msg.data[v2 + 224] + 32;
    require(v2 + msg.data[v2 + 224] + (msg.data[v2 + msg.data[v2 + 224]] << 5) + 32 <= v1);
    v16 = v17 = 0;
    while (v16 < msg.data[v2 + msg.data[v2 + 224]]) {
        MEM[v12] = msg.data[v14];
        v12 += 32;
        v14 += 32;
        v16 += 1;
    }
    require(msg.data[v2 + 256] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 256] + 31 < v1);
    v18 = 0x388a(msg.data[v2 + msg.data[v2 + 256]]);
    require(!((MEM[64] + (~0x1f & v18 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v18 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v18 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 256]];
    require(v2 + msg.data[v2 + 256] + msg.data[v2 + msg.data[v2 + 256]] + 32 <= v1);
    CALLDATACOPY(MEM[64] + 32, v2 + msg.data[v2 + 256] + 32, msg.data[v2 + msg.data[v2 + 256]]);
    MEM[32 + (MEM[64] + msg.data[v2 + msg.data[v2 + 256]])] = 0;
    if (!varg3) {
        require(msg.data[v2 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        varg3 = v19 = MEM[32 + (msg.data[v2 + 96] << 5) + MEM[64]];
    }
    v20 = _SafeAdd(varg3, varg2);
    require(msg.data[v2 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[v2 + 96] << 5) + MEM[64] + 32] = v20;
    while (v21 < MEM[MEM[64]]) {
        require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v22 = v23 = MEM[32 + (v21 << 5) + MEM[64]];
        if (0 != v23) {
            require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v24 = MEM[32 + (v21 << 5) + MEM[64]];
            if (uint8(bool(v24)) != 3) {
                v25 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v26) - MEM[64] + ~31);
                MEM[v25.data] = 32;
                MEM[v25.data + 32] = address(msg.data[v2]);
                MEM[v25.data + 64] = address(msg.data[v2 + 32]);
                MEM[v25.data + 96] = address(msg.data[v2 + 64]);
                MEM[v25.data + 128] = v21;
                MEM[v25.data + 160] = msg.data[v2 + 128];
                MEM[v25.data + 192] = msg.data[v2 + 160];
                MEM[v25.data + 224] = 288;
                MEM[v25.data + 320] = MEM[MEM[64]];
                v27 = v28 = v25.data + 320 + 32;
                v29 = v30 = MEM[64] + 32;
                v31 = v32 = 0;
                while (v31 < MEM[MEM[64]]) {
                    MEM[v27] = MEM[v29];
                    v27 += 32;
                    v29 += 32;
                    v31 += 1;
                }
                MEM[v25.data + 256] = v27 - v25.data + ~31;
                MEM[v27] = MEM[MEM[64]];
                v26 = v33 = v27 + 32;
                v34 = v35 = MEM[64] + 32;
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v26] = MEM[v34];
                    v26 += 32;
                    v34 += 32;
                    v36 += 1;
                }
                MEM[v25.data + 288] = ~31 + (v26 - v25.data);
                MEM[v26] = MEM[MEM[64]];
                v38 = v39 = 0;
                while (v38 < MEM[MEM[64]]) {
                    MEM[v38 + (v26 + 32)] = MEM[v38 + (MEM[64] + 32)];
                    v38 += 32;
                }
                if (v38 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x2437B0x1970;
                } else {
                    MEM[MEM[MEM[64]] + (v26 + 32)] = 0;
                }
                v40 = v25.length;
                v41 = v25.data;
                _refund = keccak256(v25);
                if (bool(v24) != 4) {
                    if (bool(v24) != 9) {
                        if (bool(v24) != 10) {
                            v42 = v43 = bool(v24) == 5;
                            if (bool(v24) != 5) {
                                v42 = v44 = bool(v24) == 7;
                            }
                            if (!v42) {
                                v42 = bool(v24) == 11;
                            }
                            if (!v42) {
                                if (bool(v24) != 12) {
                                    if (bool(v24) != 2) {
                                        if (bool(v24) != 6) {
                                            if (bool(v24) != 8) {
                                                require(bool(v24) == 1, Error('BBVault: TYPE'));
                                                v22 = 0;
                                                v45 = address(v24 >> 24);
                                                v46 = new array[](v25.length);
                                                v47 = v48 = 0;
                                                while (v47 < v25.length) {
                                                    MEM[v47 + v46.data] = MEM[v47 + v25.data];
                                                    v47 += 32;
                                                }
                                                if (v47 <= v25.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x2437B0x1970;
                                                } else {
                                                    MEM[v25.length + v46.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x2437B0x1970;
                                            } else {
                                                v49 = v50 = address(v24 >> 24);
                                                v51 = new array[](v23);
                                                v52 = new array[](160);
                                                v53 = new array[](v25.length);
                                                v54 = v55 = 0;
                                                while (v54 < v25.length) {
                                                    MEM[v54 + v53.data] = MEM[v54 + v25.data];
                                                    v54 += 32;
                                                }
                                                if (v54 <= v25.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x2437B0x1970;
                                                } else {
                                                    MEM[v25.length + v53.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x2437B0x1970;
                                            }
                                        } else {
                                            v56 = new array[](v25.length);
                                            v57 = v58 = 0;
                                            while (v57 < v25.length) {
                                                MEM[v57 + v56.data] = MEM[v57 + v25.data];
                                                v57 += 32;
                                            }
                                            if (v57 <= v25.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x2437B0x1970;
                                            } else {
                                                MEM[v25.length + v56.data] = 0;
                                            }
                                            require(bool((address(v24 >> 24)).code.size));
                                            v59, /* bool */ v60 = address(v24 >> 24).flashLoan(address(this), address(msg.data[v2 + 64]), v23, v56).gas(msg.gas);
                                            require(bool(v59), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v60 == bool(v60));
                                            require(v60, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x2437B0x1970;
                                        }
                                    } else {
                                        v22 = v61 = 0;
                                        v45 = v62 = address(v24 >> 24);
                                        v63 = new array[](v25.length);
                                        v64 = v65 = 0;
                                        while (v64 < v25.length) {
                                            MEM[v64 + v63.data] = MEM[v64 + v25.data];
                                            v64 += 32;
                                        }
                                        if (v64 <= v25.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x2437B0x1970;
                                        } else {
                                            MEM[v25.length + v63.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x2437B0x1970;
                                    }
                                } else {
                                    if (v24 & 0x10) {
                                        v22 = v66 = v23 << 128;
                                    }
                                    v49 = address(v24 >> 24);
                                    v67 = new array[](v25.length);
                                    v68 = v69 = 0;
                                    while (v68 < v25.length) {
                                        MEM[v68 + v67.data] = MEM[v68 + v25.data];
                                        v68 += 32;
                                    }
                                    if (v68 <= v25.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x2437B0x1970;
                                    } else {
                                        MEM[v25.length + v67.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x2437B0x1970;
                                }
                            } else {
                                v49 = v70 = address(v24 >> 24);
                                v71 = new array[](128);
                                v72 = new array[](v25.length);
                                v73 = v74 = 0;
                                while (v73 < v25.length) {
                                    MEM[v73 + v72.data] = MEM[v73 + v25.data];
                                    v73 += 32;
                                }
                                if (v73 <= v25.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x2437B0x1970;
                                } else {
                                    MEM[v25.length + v72.data] = 0;
                                }
                            }
                            require(bool(v49.code.size));
                            v75 = v49.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v22, address(msg.data[v2 + 64]), address(this), v71, v51, v67, v72, v52, v53).gas(msg.gas);
                            require(bool(v75), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x2437B0x1970;
                        } else {
                            v22 = v76 = 0;
                            v45 = v77 = address(v24 >> 24);
                            v78 = new array[](v25.length);
                            v79 = v80 = 0;
                            while (v79 < v25.length) {
                                MEM[v79 + v78.data] = MEM[v79 + v25.data];
                                v79 += 32;
                            }
                            if (v79 <= v25.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x2437B0x1970;
                            } else {
                                MEM[v25.length + v78.data] = 0;
                            }
                        }
                    } else {
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = address(msg.data[v2 + 64]);
                        v83 = new uint256[](1);
                        CALLDATACOPY(v83.data, msg.data.length, 32);
                        require(0 < v83.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v84 = v83.data;
                        v83[0] = v23;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v45 = v85 = address(v24 >> 24);
                        v86 = new uint256[](v81.length);
                        v87 = v88 = v86.data;
                        v89 = v90 = v81.data;
                        v91 = v92 = 0;
                        while (v91 < v81.length) {
                            MEM[v87] = address(MEM[v89]);
                            v87 += 32;
                            v89 += 32;
                            v91 += 1;
                        }
                        MEM[v87] = v83.length;
                        v93 = v94 = v87 + 32;
                        v95 = v96 = v83.data;
                        v97 = v98 = 0;
                        while (v97 < v83.length) {
                            MEM[v93] = MEM[v95];
                            v93 += 32;
                            v95 += 32;
                            v97 += 1;
                        }
                        MEM[v93] = v25.length;
                        v99 = v100 = 0;
                        while (v99 < v25.length) {
                            MEM[v99 + (v93 + 32)] = MEM[v99 + v25.data];
                            v99 += 32;
                        }
                        if (v99 <= v25.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x2437B0x1970;
                        } else {
                            MEM[v25.length + (v93 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x2437B0x1970;
                    }
                    require(bool(v45.code.size));
                    v101 = v45.call(v86, v78, v63, v46, v22, v22, address(this), address(this), v86, v78, v63, v46, 1, v22, v87 - (4 + MEM[64]), address(this), address(this), v86, v78, v63, v46, v102, address(msg.data[v2 + 64])).gas(msg.gas);
                    require(bool(v101), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = address(msg.data[v2 + 64]);
                    v105 = new uint256[](1);
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = v105.data;
                    v105[0] = v23;
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = new uint256[](v103.length);
                    v109 = v110 = v108.data;
                    v111 = v112 = v103.data;
                    v113 = v114 = 0;
                    while (v113 < v103.length) {
                        MEM[v109] = address(MEM[v111]);
                        v109 += 32;
                        v111 += 32;
                        v113 += 1;
                    }
                    v109 = new uint256[](v105.length);
                    v115 = v116 = v109.data;
                    v117 = v118 = v105.data;
                    v119 = v120 = 0;
                    while (v119 < v105.length) {
                        MEM[v115] = MEM[v117];
                        v115 += 32;
                        v117 += 32;
                        v119 += 1;
                    }
                    v115 = new uint256[](v107.length);
                    v121 = v122 = v115.data;
                    v123 = v124 = v107.data;
                    v125 = v126 = 0;
                    while (v125 < v107.length) {
                        MEM[v121] = MEM[v123];
                        v121 += 32;
                        v123 += 32;
                        v125 += 1;
                    }
                    v121 = new array[](v25.length);
                    v127 = v128 = 0;
                    while (v127 < v25.length) {
                        MEM[v127 + v121.data] = MEM[v127 + v25.data];
                        v127 += 32;
                    }
                    if (v127 <= v25.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x2437B0x1970;
                    } else {
                        MEM[v25.length + v121.data] = 0;
                    }
                    require(bool((address(v24 >> 24)).code.size));
                    v129 = address(v24 >> 24).flashLoan(address(this), v108, v109, v115, address(this), v121, uint16(0), v102, address(msg.data[v2 + 64])).gas(msg.gas);
                    require(bool(v129), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x2437B0x1970;
                }
                goto 0x50090x2437B0x1970;
            } else {
                require(bool((address(v24 >> 24)).code.size));
                v130 = address(v24 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[v2 + 64]), v23, this).gas(msg.gas);
                require(bool(v130), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v21 += 1;
    }
    if (msg.data[v2 + 128]) {
        0x20f3(msg.data[v2 + 128], msg.data[v2 + 32], msg.data[v2 + 64]);
    }
    v131 = v132 = 0;
    while (v131 < MEM[MEM[64]]) {
        require(v131 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v133 = v133 + MEM[32 + (v131 << 5) + MEM[64]];
        v131 += 1;
    }
    _refund = 'EXECUTION';
    v134 = new array[](MEM[MEM[64]]);
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        MEM[v135 + v134.data] = MEM[v135 + (MEM[64] + 32)];
        v135 += 32;
    }
    if (v135 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x2437B0x1970;
    } else {
        MEM[MEM[MEM[64]] + v134.data] = 0;
    }
    require(bool((address(msg.data[v2])).code.size));
    v137 = address(msg.data[v2]).call(0x7fe3ba8b, address(msg.data[v2 + 32]), v133, v134).gas(msg.gas);
    require(bool(v137), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v138 = v139 = 0;
    while (v138 < MEM[MEM[64]]) {
        require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v140 = v141 = MEM[32 + (v138 << 5) + MEM[64]];
        if (0 != v141) {
            require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v142 = v143 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v138 << 5) + MEM[64] + 32]) != 4) {
                v142 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v142) {
                if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v144 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v144), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v140 = MEM[MEM[64]];
                }
                if (v140) {
                    0x20f3(v140, MEM[(v138 << 5) + MEM[64] + 32] >> 24, msg.data[v2 + 64]);
                    if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v145 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v145), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v141;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v138 << 5) + MEM[64] + 32] >> 24));
                v146 = v147 = 0;
                while (v146 < 68) {
                    MEM[v146 + MEM[64]] = MEM[v146 + (MEM[64] + 32)];
                    v146 += 32;
                }
                if (v146 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x2437B0x1970;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v148 = v149 = address(msg.data[v2 + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v150 = v151 = 96;
                } else {
                    v150 = v152 = MEM[64];
                    MEM[64] = v152 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v152] = RETURNDATASIZE();
                    RETURNDATACOPY(v152 + 32, 0, RETURNDATASIZE());
                }
                if (v149) {
                    v148 = v153 = !MEM[v150];
                    if (MEM[v150]) {
                        require(32 + v150 + MEM[v150] - (32 + v150) >= 32);
                        v148 = MEM[32 + v150];
                        require(v148 == bool(v148));
                    }
                }
                require(v148, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v138 += 1;
    }
    return ;
}

function 0x20f3(uint256 varg0, address varg1, address varg2) private { 
    v0 = v1 = 0;
    while (v0 < 68) {
        MEM[v0 + MEM[64]] = MEM[v0 + (MEM[64] + 32)];
        v0 += 32;
    }
    if (v0 <= 68) {
        goto 0x33aa0x3398B0x20f3;
    } else {
        MEM[68 + MEM[64]] = 0;
    }
    v2 = v3, v4, v5 = varg2.transfer(varg1, varg0).gas(msg.gas);
    if (RETURNDATASIZE() == 0) {
        v6 = v7 = 96;
    } else {
        v6 = new bytes[](RETURNDATASIZE());
        RETURNDATACOPY(v6.data, 0, RETURNDATASIZE());
    }
    if (v3) {
        v2 = v8 = !MEM[v6];
        if (MEM[v6]) {
            require(32 + v6 + MEM[v6] - (32 + v6) >= 32);
            v2 = MEM[32 + v6];
            require(v2 == bool(v2));
        }
    }
    require(v2, Error('BBVault: TRANSFER_FAILED'));
    return ;
}

function 0x24ed(address varg0, address varg1) private { 
    v0 = v1 = 0;
    while (v0 < 36) {
        MEM[v0 + MEM[64]] = MEM[v0 + (MEM[64] + 32)];
        v0 += 32;
    }
    if (v0 <= 36) {
        goto 0x33aa0x3398B0x25210x24ed;
    } else {
        MEM[36 + MEM[64]] = 0;
    }
    v2, v3, v4 = varg1.balanceOf(varg0).gas(msg.gas);
    if (RETURNDATASIZE() == 0) {
        v5 = v6 = 96;
    } else {
        v5 = new bytes[](RETURNDATASIZE());
        RETURNDATACOPY(v5.data, 0, RETURNDATASIZE());
    }
    if (v2) {
        v2 = v7 = MEM[v5] >= 32;
    }
    require(v2);
    require(32 + v5 + MEM[v5] - (32 + v5) >= 32);
    return MEM[32 + v5];
}

function 0x25d4(uint256 varg0, uint256 varg1) private { 
    v0 = 0x24ed(this, varg1);
    require(v0 >= varg0, Error('BBVault: REFUND'));
    if (varg0 != v0) {
        emit 0xe36afff562bb3667516fd46110e5d9016e2842add1e931f493195be47a7c9418(address(varg1), uint96(v0 - varg0));
    }
    _refund = 0;
    return ;
}

function settle(address varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(_refund == 'SETTLE', Error('BBVault: STATUS'));
    _refund = 0;
    if (varg1) {
        v0 = v1 = 0;
        while (v0 < 100) {
            MEM[v0 + MEM[64]] = MEM[v0 + (MEM[64] + 32)];
            v0 += 32;
        }
        if (v0 <= 100) {
            goto 0x33aa0x3398B0x231bB0x9a6B0x2e3;
        } else {
            MEM[100 + MEM[64]] = 0;
        }
        v2 = v3, v4, v5 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);
        if (RETURNDATASIZE() == 0) {
            v6 = v7 = 96;
        } else {
            v6 = v8 = new bytes[](RETURNDATASIZE());
            RETURNDATACOPY(v8.data, 0, RETURNDATASIZE());
        }
        if (v3) {
            v2 = v9 = !MEM[v6];
            if (MEM[v6]) {
                require(v5 + MEM[v6] - v5 >= 32);
                v2 = MEM[v5];
                require(v2 == bool(v2));
            }
        }
        require(v2, Error('BBVault: TRANSFER_FROM_FAILED'));
        emit 0xe36afff562bb3667516fd46110e5d9016e2842add1e931f493195be47a7c9418(varg0, uint96(varg1));
    }
}

function 0x1faa6b87(address varg0, address varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { 
    require(msg.data.length - 4 >= 192);
    require(varg0 == varg0);
    require(varg1 == varg1);
    require(varg2 == varg2);
    require(varg5 <= 0xffffffffffffffff);
    require(4 + varg5 + 31 < msg.data.length);
    require(varg5.length <= 0xffffffffffffffff);
    require(4 + varg5 + varg5.length + 32 <= msg.data.length);
    v0 = v1 = uint128(varg3);
    if (!v1) {
        v0 = v2 = varg3 >> 128;
        v3 = v4 = varg4 >> 128;
    } else {
        v3 = v5 = uint128(varg4);
    }
    CALLDATACOPY(v6.data, varg5.data, varg5.length);
    MEM[varg5.length + v6.data] = 0;
    require(_refund == keccak256(v6.data), Error('BBVault: STATUS'));
    require(varg5.data + varg5.length - varg5.data >= 32);
    require(msg.data[varg5.data] <= 0xffffffffffffffff);
    require(varg5.data + varg5.length - (varg5.data + msg.data[varg5.data]) >= 288);
    v7 = MEM[64];
    require(!((v7 + 288 < v7) | (v7 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v7 + 288;
    require(varg5[msg.data[varg5.data]] == address(varg5[msg.data[varg5.data]]));
    require(msg.data[varg5.data + msg.data[varg5.data] + 32] == address(msg.data[varg5.data + msg.data[varg5.data] + 32]));
    require(msg.data[varg5.data + msg.data[varg5.data] + 64] == address(msg.data[varg5.data + msg.data[varg5.data] + 64]));
    require(msg.data[varg5.data + msg.data[varg5.data] + 192] <= 0xffffffffffffffff);
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192] + 31 < varg5.data + varg5.length);
    v8 = 0x3867(msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v8 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v8 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v8 + 31);
    MEM[MEM[64]] = msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192]];
    v9 = v10 = MEM[64] + 32;
    v11 = v12 = varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192] + 32;
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192] + (msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192]] << 5) + 32 <= varg5.data + varg5.length);
    v13 = v14 = 0;
    while (v13 < msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 192]]) {
        MEM[v9] = msg.data[v11];
        v9 += 32;
        v11 += 32;
        v13 += 1;
    }
    require(msg.data[varg5.data + msg.data[varg5.data] + 224] <= 0xffffffffffffffff);
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224] + 31 < varg5.data + varg5.length);
    v15 = 0x3867(msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v15 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v15 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v15 + 31);
    MEM[MEM[64]] = msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224]];
    v16 = v17 = MEM[64] + 32;
    v18 = v19 = varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224] + 32;
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224] + (msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224]] << 5) + 32 <= varg5.data + varg5.length);
    v20 = v21 = 0;
    while (v20 < msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 224]]) {
        MEM[v16] = msg.data[v18];
        v16 += 32;
        v18 += 32;
        v20 += 1;
    }
    require(msg.data[varg5.data + msg.data[varg5.data] + 256] <= 0xffffffffffffffff);
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256] + 31 < varg5.data + varg5.length);
    v22 = 0x388a(msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v22 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v22 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v22 + 31);
    MEM[MEM[64]] = msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256]];
    require(varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256] + msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256]] + 32 <= varg5.data + varg5.length);
    CALLDATACOPY(MEM[64] + 32, varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256] + 32, msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg5.data + msg.data[varg5.data] + msg.data[varg5.data + msg.data[varg5.data] + 256]])] = 0;
    if (!v23) {
        require(msg.data[varg5.data + msg.data[varg5.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v0 = MEM[32 + (msg.data[varg5.data + msg.data[varg5.data] + 96] << 5) + MEM[64]];
    }
    v24 = _SafeAdd(v0, v3);
    require(msg.data[varg5.data + msg.data[varg5.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg5.data + msg.data[varg5.data] + 96] << 5) + MEM[64] + 32] = v24;
    while (v25 < MEM[MEM[64]]) {
        require(v25 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v26 = v27 = MEM[32 + (v25 << 5) + MEM[64]];
        if (0 != v27) {
            require(v25 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v28 = MEM[32 + (v25 << 5) + MEM[64]];
            if (uint8(bool(v28)) != 3) {
                v29 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v30) - MEM[64] + ~31);
                MEM[v29.data] = 32;
                MEM[v29.data + 32] = address(varg5[msg.data[varg5.data]]);
                MEM[v29.data + 64] = address(msg.data[varg5.data + msg.data[varg5.data] + 32]);
                MEM[v29.data + 96] = address(msg.data[varg5.data + msg.data[varg5.data] + 64]);
                MEM[v29.data + 128] = v25;
                MEM[v29.data + 160] = msg.data[varg5.data + msg.data[varg5.data] + 128];
                MEM[v29.data + 192] = msg.data[varg5.data + msg.data[varg5.data] + 160];
                MEM[v29.data + 224] = 288;
                MEM[v29.data + 320] = MEM[MEM[64]];
                v31 = v32 = v29.data + 320 + 32;
                v33 = v34 = MEM[64] + 32;
                v35 = v36 = 0;
                while (v35 < MEM[MEM[64]]) {
                    MEM[v31] = MEM[v33];
                    v31 += 32;
                    v33 += 32;
                    v35 += 1;
                }
                MEM[v29.data + 256] = v31 - v29.data + ~31;
                MEM[v31] = MEM[MEM[64]];
                v30 = v37 = v31 + 32;
                v38 = v39 = MEM[64] + 32;
                v40 = v41 = 0;
                while (v40 < MEM[MEM[64]]) {
                    MEM[v30] = MEM[v38];
                    v30 += 32;
                    v38 += 32;
                    v40 += 1;
                }
                MEM[v29.data + 288] = ~31 + (v30 - v29.data);
                MEM[v30] = MEM[MEM[64]];
                v42 = v43 = 0;
                while (v42 < MEM[MEM[64]]) {
                    MEM[v42 + (v30 + 32)] = MEM[v42 + (MEM[64] + 32)];
                    v42 += 32;
                }
                if (v42 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x2437B0xa34;
                } else {
                    MEM[MEM[MEM[64]] + (v30 + 32)] = 0;
                }
                v44 = v29.length;
                v45 = v29.data;
                _refund = keccak256(v29);
                if (bool(v28) != 4) {
                    if (bool(v28) != 9) {
                        if (bool(v28) != 10) {
                            v46 = v47 = bool(v28) == 5;
                            if (bool(v28) != 5) {
                                v46 = v48 = bool(v28) == 7;
                            }
                            if (!v46) {
                                v46 = bool(v28) == 11;
                            }
                            if (!v46) {
                                if (bool(v28) != 12) {
                                    if (bool(v28) != 2) {
                                        if (bool(v28) != 6) {
                                            if (bool(v28) != 8) {
                                                require(bool(v28) == 1, Error('BBVault: TYPE'));
                                                v26 = 0;
                                                v49 = address(v28 >> 24);
                                                v50 = new array[](v29.length);
                                                v51 = v52 = 0;
                                                while (v51 < v29.length) {
                                                    MEM[v51 + v50.data] = MEM[v51 + v29.data];
                                                    v51 += 32;
                                                }
                                                if (v51 <= v29.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x2437B0xa34;
                                                } else {
                                                    MEM[v29.length + v50.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x2437B0xa34;
                                            } else {
                                                v53 = v54 = address(v28 >> 24);
                                                v55 = new array[](v27);
                                                v56 = new array[](160);
                                                v57 = new array[](v29.length);
                                                v58 = v59 = 0;
                                                while (v58 < v29.length) {
                                                    MEM[v58 + v57.data] = MEM[v58 + v29.data];
                                                    v58 += 32;
                                                }
                                                if (v58 <= v29.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x2437B0xa34;
                                                } else {
                                                    MEM[v29.length + v57.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x2437B0xa34;
                                            }
                                        } else {
                                            v60 = new array[](v29.length);
                                            v61 = v62 = 0;
                                            while (v61 < v29.length) {
                                                MEM[v61 + v60.data] = MEM[v61 + v29.data];
                                                v61 += 32;
                                            }
                                            if (v61 <= v29.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x2437B0xa34;
                                            } else {
                                                MEM[v29.length + v60.data] = 0;
                                            }
                                            require(bool((address(v28 >> 24)).code.size));
                                            v63, /* bool */ v64 = address(v28 >> 24).flashLoan(address(this), address(msg.data[varg5.data + msg.data[varg5.data] + 64]), v27, v60).gas(msg.gas);
                                            require(bool(v63), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v64 == bool(v64));
                                            require(v64, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x2437B0xa34;
                                        }
                                    } else {
                                        v26 = v65 = 0;
                                        v49 = v66 = address(v28 >> 24);
                                        v67 = new array[](v29.length);
                                        v68 = v69 = 0;
                                        while (v68 < v29.length) {
                                            MEM[v68 + v67.data] = MEM[v68 + v29.data];
                                            v68 += 32;
                                        }
                                        if (v68 <= v29.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x2437B0xa34;
                                        } else {
                                            MEM[v29.length + v67.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x2437B0xa34;
                                    }
                                } else {
                                    if (v28 & 0x10) {
                                        v26 = v70 = v27 << 128;
                                    }
                                    v53 = address(v28 >> 24);
                                    v71 = new array[](v29.length);
                                    v72 = v73 = 0;
                                    while (v72 < v29.length) {
                                        MEM[v72 + v71.data] = MEM[v72 + v29.data];
                                        v72 += 32;
                                    }
                                    if (v72 <= v29.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x2437B0xa34;
                                    } else {
                                        MEM[v29.length + v71.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x2437B0xa34;
                                }
                            } else {
                                v53 = v74 = address(v28 >> 24);
                                v75 = new array[](128);
                                v76 = new array[](v29.length);
                                v77 = v78 = 0;
                                while (v77 < v29.length) {
                                    MEM[v77 + v76.data] = MEM[v77 + v29.data];
                                    v77 += 32;
                                }
                                if (v77 <= v29.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x2437B0xa34;
                                } else {
                                    MEM[v29.length + v76.data] = 0;
                                }
                            }
                            require(bool(v53.code.size));
                            v79 = v53.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v26, address(msg.data[varg5.data + msg.data[varg5.data] + 64]), address(this), v75, v55, v71, v76, v56, v57).gas(msg.gas);
                            require(bool(v79), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x2437B0xa34;
                        } else {
                            v26 = v80 = 0;
                            v49 = v81 = address(v28 >> 24);
                            v82 = new array[](v29.length);
                            v83 = v84 = 0;
                            while (v83 < v29.length) {
                                MEM[v83 + v82.data] = MEM[v83 + v29.data];
                                v83 += 32;
                            }
                            if (v83 <= v29.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x2437B0xa34;
                            } else {
                                MEM[v29.length + v82.data] = 0;
                            }
                        }
                    } else {
                        v85 = new uint256[](1);
                        CALLDATACOPY(v85.data, msg.data.length, 32);
                        require(0 < v85.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v86 = v85.data;
                        v85[0] = address(msg.data[varg5.data + msg.data[varg5.data] + 64]);
                        v87 = new uint256[](1);
                        CALLDATACOPY(v87.data, msg.data.length, 32);
                        require(0 < v87.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v88 = v87.data;
                        v87[0] = v27;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v49 = v89 = address(v28 >> 24);
                        v90 = new uint256[](v85.length);
                        v91 = v92 = v90.data;
                        v93 = v94 = v85.data;
                        v95 = v96 = 0;
                        while (v95 < v85.length) {
                            MEM[v91] = address(MEM[v93]);
                            v91 += 32;
                            v93 += 32;
                            v95 += 1;
                        }
                        MEM[v91] = v87.length;
                        v97 = v98 = v91 + 32;
                        v99 = v100 = v87.data;
                        v101 = v102 = 0;
                        while (v101 < v87.length) {
                            MEM[v97] = MEM[v99];
                            v97 += 32;
                            v99 += 32;
                            v101 += 1;
                        }
                        MEM[v97] = v29.length;
                        v103 = v104 = 0;
                        while (v103 < v29.length) {
                            MEM[v103 + (v97 + 32)] = MEM[v103 + v29.data];
                            v103 += 32;
                        }
                        if (v103 <= v29.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x2437B0xa34;
                        } else {
                            MEM[v29.length + (v97 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x2437B0xa34;
                    }
                    require(bool(v49.code.size));
                    v105 = v49.call(v90, v82, v67, v50, v26, v26, address(this), address(this), v90, v82, v67, v50, 1, v26, v91 - (4 + MEM[64]), address(this), address(this), v90, v82, v67, v50, v106, address(msg.data[varg5.data + msg.data[varg5.data] + 64])).gas(msg.gas);
                    require(bool(v105), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v107 = new uint256[](1);
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = v107.data;
                    v107[0] = address(msg.data[varg5.data + msg.data[varg5.data] + 64]);
                    v109 = new uint256[](1);
                    CALLDATACOPY(v109.data, msg.data.length, 32);
                    require(0 < v109.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v110 = v109.data;
                    v109[0] = v27;
                    CALLDATACOPY(v111.data, msg.data.length, 32);
                    require(0 < v111.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v112 = new uint256[](v107.length);
                    v113 = v114 = v112.data;
                    v115 = v116 = v107.data;
                    v117 = v118 = 0;
                    while (v117 < v107.length) {
                        MEM[v113] = address(MEM[v115]);
                        v113 += 32;
                        v115 += 32;
                        v117 += 1;
                    }
                    v113 = new uint256[](v109.length);
                    v119 = v120 = v113.data;
                    v121 = v122 = v109.data;
                    v123 = v124 = 0;
                    while (v123 < v109.length) {
                        MEM[v119] = MEM[v121];
                        v119 += 32;
                        v121 += 32;
                        v123 += 1;
                    }
                    v119 = new uint256[](v111.length);
                    v125 = v126 = v119.data;
                    v127 = v128 = v111.data;
                    v129 = v130 = 0;
                    while (v129 < v111.length) {
                        MEM[v125] = MEM[v127];
                        v125 += 32;
                        v127 += 32;
                        v129 += 1;
                    }
                    v125 = new array[](v29.length);
                    v131 = v132 = 0;
                    while (v131 < v29.length) {
                        MEM[v131 + v125.data] = MEM[v131 + v29.data];
                        v131 += 32;
                    }
                    if (v131 <= v29.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x2437B0xa34;
                    } else {
                        MEM[v29.length + v125.data] = 0;
                    }
                    require(bool((address(v28 >> 24)).code.size));
                    v133 = address(v28 >> 24).flashLoan(address(this), v112, v113, v119, address(this), v125, uint16(0), v106, address(msg.data[varg5.data + msg.data[varg5.data] + 64])).gas(msg.gas);
                    require(bool(v133), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x2437B0xa34;
                }
                goto 0x50090x2437B0xa34;
            } else {
                require(bool((address(v28 >> 24)).code.size));
                v134 = address(v28 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg5.data + msg.data[varg5.data] + 64]), v27, this).gas(msg.gas);
                require(bool(v134), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v25 += 1;
    }
    if (msg.data[varg5.data + msg.data[varg5.data] + 128]) {
        0x20f3(msg.data[varg5.data + msg.data[varg5.data] + 128], msg.data[varg5.data + msg.data[varg5.data] + 32], msg.data[varg5.data + msg.data[varg5.data] + 64]);
    }
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        require(v135 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v137 = v137 + MEM[32 + (v135 << 5) + MEM[64]];
        v135 += 1;
    }
    _refund = 'EXECUTION';
    v138 = new array[](MEM[MEM[64]]);
    v139 = v140 = 0;
    while (v139 < MEM[MEM[64]]) {
        MEM[v139 + v138.data] = MEM[v139 + (MEM[64] + 32)];
        v139 += 32;
    }
    if (v139 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x2437B0xa34;
    } else {
        MEM[MEM[MEM[64]] + v138.data] = 0;
    }
    require(bool((address(varg5[msg.data[varg5.data]])).code.size));
    v141 = address(varg5[msg.data[varg5.data]]).call(0x7fe3ba8b, address(msg.data[varg5.data + msg.data[varg5.data] + 32]), v137, v138).gas(msg.gas);
    require(bool(v141), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v142 = v143 = 0;
    while (v142 < MEM[MEM[64]]) {
        require(v142 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v144 = v145 = MEM[32 + (v142 << 5) + MEM[64]];
        if (0 != v145) {
            require(v142 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v146 = v147 = bool(MEM[(v142 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v142 << 5) + MEM[64] + 32]) != 4) {
                v146 = bool(MEM[(v142 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v146) {
                if (bool(MEM[(v142 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v142 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v148 = address(MEM[(v142 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v148), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v144 = MEM[MEM[64]];
                }
                if (v144) {
                    0x20f3(v144, MEM[(v142 << 5) + MEM[64] + 32] >> 24, msg.data[varg5.data + msg.data[varg5.data] + 64]);
                    if (bool(MEM[(v142 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v142 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v149 = address(MEM[(v142 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v149), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v145;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v142 << 5) + MEM[64] + 32] >> 24));
                v150 = v151 = 0;
                while (v150 < 68) {
                    MEM[v150 + MEM[64]] = MEM[v150 + (MEM[64] + 32)];
                    v150 += 32;
                }
                if (v150 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x2437B0xa34;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v152 = v153 = address(msg.data[varg5.data + msg.data[varg5.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v154 = v155 = 96;
                } else {
                    v154 = v156 = MEM[64];
                    MEM[64] = v156 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v156] = RETURNDATASIZE();
                    RETURNDATACOPY(v156 + 32, 0, RETURNDATASIZE());
                }
                if (v153) {
                    v152 = v157 = !MEM[v154];
                    if (MEM[v154]) {
                        require(32 + v154 + MEM[v154] - (32 + v154) >= 32);
                        v152 = MEM[32 + v154];
                        require(v152 == bool(v152));
                    }
                }
                require(v152, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v142 += 1;
    }
    return 0xab5c473bce5960a8292e9c8db82f9272504caab4e9ef09553fc112f82b62a3c2;
}

function onFlashLoan(address varg0, address varg1, uint256 varg2, uint256 varg3, bytes varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 == varg0);
    require(varg1 == varg1);
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= 0xffffffffffffffff);
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    CALLDATACOPY(v0.data, varg4.data, varg4.length);
    MEM[varg4.length + v0.data] = 0;
    require(_refund == keccak256(v0.data), Error('BBVault: STATUS'));
    require(varg4.data + varg4.length - varg4.data >= 32);
    require(msg.data[varg4.data] <= 0xffffffffffffffff);
    require(varg4.data + varg4.length - (varg4.data + msg.data[varg4.data]) >= 288);
    v1 = MEM[64];
    require(!((v1 + 288 < v1) | (v1 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v1 + 288;
    require(varg4[msg.data[varg4.data]] == address(varg4[msg.data[varg4.data]]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 32] == address(msg.data[varg4.data + msg.data[varg4.data] + 32]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 64] == address(msg.data[varg4.data + msg.data[varg4.data] + 64]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 192] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 31 < varg4.data + varg4.length);
    v2 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v2 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v2 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v2 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]];
    v3 = v4 = MEM[64] + 32;
    v5 = v6 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]] << 5) + 32 <= varg4.data + varg4.length);
    v7 = v8 = 0;
    while (v7 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]) {
        MEM[v3] = msg.data[v5];
        v3 += 32;
        v5 += 32;
        v7 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 224] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 31 < varg4.data + varg4.length);
    v9 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v9 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v9 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v9 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]];
    v10 = v11 = MEM[64] + 32;
    v12 = v13 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]] << 5) + 32 <= varg4.data + varg4.length);
    v14 = v15 = 0;
    while (v14 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]) {
        MEM[v10] = msg.data[v12];
        v10 += 32;
        v12 += 32;
        v14 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 256] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 31 < varg4.data + varg4.length);
    v16 = 0x388a(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v16 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v16 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v16 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]];
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]] + 32 <= varg4.data + varg4.length);
    CALLDATACOPY(MEM[64] + 32, varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 32, msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]])] = 0;
    if (!varg2) {
        require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v17 = MEM[32 + (msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64]];
    }
    v18 = _SafeAdd(v17, varg3);
    require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64] + 32] = v18;
    while (v19 < MEM[MEM[64]]) {
        require(v19 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v20 = v21 = MEM[32 + (v19 << 5) + MEM[64]];
        if (0 != v21) {
            require(v19 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v22 = MEM[32 + (v19 << 5) + MEM[64]];
            if (uint8(bool(v22)) != 3) {
                v23 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v24) - MEM[64] + ~31);
                MEM[v23.data] = 32;
                MEM[v23.data + 32] = address(varg4[msg.data[varg4.data]]);
                MEM[v23.data + 64] = address(msg.data[varg4.data + msg.data[varg4.data] + 32]);
                MEM[v23.data + 96] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                MEM[v23.data + 128] = v19;
                MEM[v23.data + 160] = msg.data[varg4.data + msg.data[varg4.data] + 128];
                MEM[v23.data + 192] = msg.data[varg4.data + msg.data[varg4.data] + 160];
                MEM[v23.data + 224] = 288;
                MEM[v23.data + 320] = MEM[MEM[64]];
                v25 = v26 = v23.data + 320 + 32;
                v27 = v28 = MEM[64] + 32;
                v29 = v30 = 0;
                while (v29 < MEM[MEM[64]]) {
                    MEM[v25] = MEM[v27];
                    v25 += 32;
                    v27 += 32;
                    v29 += 1;
                }
                MEM[v23.data + 256] = v25 - v23.data + ~31;
                MEM[v25] = MEM[MEM[64]];
                v24 = v31 = v25 + 32;
                v32 = v33 = MEM[64] + 32;
                v34 = v35 = 0;
                while (v34 < MEM[MEM[64]]) {
                    MEM[v24] = MEM[v32];
                    v24 += 32;
                    v32 += 32;
                    v34 += 1;
                }
                MEM[v23.data + 288] = ~31 + (v24 - v23.data);
                MEM[v24] = MEM[MEM[64]];
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v36 + (v24 + 32)] = MEM[v36 + (MEM[64] + 32)];
                    v36 += 32;
                }
                if (v36 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x2437B0xa6f;
                } else {
                    MEM[MEM[MEM[64]] + (v24 + 32)] = 0;
                }
                v38 = v23.length;
                v39 = v23.data;
                _refund = keccak256(v23);
                if (bool(v22) != 4) {
                    if (bool(v22) != 9) {
                        if (bool(v22) != 10) {
                            v40 = v41 = bool(v22) == 5;
                            if (bool(v22) != 5) {
                                v40 = v42 = bool(v22) == 7;
                            }
                            if (!v40) {
                                v40 = bool(v22) == 11;
                            }
                            if (!v40) {
                                if (bool(v22) != 12) {
                                    if (bool(v22) != 2) {
                                        if (bool(v22) != 6) {
                                            if (bool(v22) != 8) {
                                                require(bool(v22) == 1, Error('BBVault: TYPE'));
                                                v20 = 0;
                                                v43 = address(v22 >> 24);
                                                v44 = new array[](v23.length);
                                                v45 = v46 = 0;
                                                while (v45 < v23.length) {
                                                    MEM[v45 + v44.data] = MEM[v45 + v23.data];
                                                    v45 += 32;
                                                }
                                                if (v45 <= v23.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x2437B0xa6f;
                                                } else {
                                                    MEM[v23.length + v44.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x2437B0xa6f;
                                            } else {
                                                v47 = v48 = address(v22 >> 24);
                                                v49 = new array[](v21);
                                                v50 = new array[](160);
                                                v51 = new array[](v23.length);
                                                v52 = v53 = 0;
                                                while (v52 < v23.length) {
                                                    MEM[v52 + v51.data] = MEM[v52 + v23.data];
                                                    v52 += 32;
                                                }
                                                if (v52 <= v23.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x2437B0xa6f;
                                                } else {
                                                    MEM[v23.length + v51.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x2437B0xa6f;
                                            }
                                        } else {
                                            v54 = new array[](v23.length);
                                            v55 = v56 = 0;
                                            while (v55 < v23.length) {
                                                MEM[v55 + v54.data] = MEM[v55 + v23.data];
                                                v55 += 32;
                                            }
                                            if (v55 <= v23.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x2437B0xa6f;
                                            } else {
                                                MEM[v23.length + v54.data] = 0;
                                            }
                                            require(bool((address(v22 >> 24)).code.size));
                                            v57, /* bool */ v58 = address(v22 >> 24).flashLoan(address(this), address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v21, v54).gas(msg.gas);
                                            require(bool(v57), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v58 == bool(v58));
                                            require(v58, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x2437B0xa6f;
                                        }
                                    } else {
                                        v20 = v59 = 0;
                                        v43 = v60 = address(v22 >> 24);
                                        v61 = new array[](v23.length);
                                        v62 = v63 = 0;
                                        while (v62 < v23.length) {
                                            MEM[v62 + v61.data] = MEM[v62 + v23.data];
                                            v62 += 32;
                                        }
                                        if (v62 <= v23.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x2437B0xa6f;
                                        } else {
                                            MEM[v23.length + v61.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x2437B0xa6f;
                                    }
                                } else {
                                    if (v22 & 0x10) {
                                        v20 = v64 = v21 << 128;
                                    }
                                    v47 = address(v22 >> 24);
                                    v65 = new array[](v23.length);
                                    v66 = v67 = 0;
                                    while (v66 < v23.length) {
                                        MEM[v66 + v65.data] = MEM[v66 + v23.data];
                                        v66 += 32;
                                    }
                                    if (v66 <= v23.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x2437B0xa6f;
                                    } else {
                                        MEM[v23.length + v65.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x2437B0xa6f;
                                }
                            } else {
                                v47 = v68 = address(v22 >> 24);
                                v69 = new array[](128);
                                v70 = new array[](v23.length);
                                v71 = v72 = 0;
                                while (v71 < v23.length) {
                                    MEM[v71 + v70.data] = MEM[v71 + v23.data];
                                    v71 += 32;
                                }
                                if (v71 <= v23.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x2437B0xa6f;
                                } else {
                                    MEM[v23.length + v70.data] = 0;
                                }
                            }
                            require(bool(v47.code.size));
                            v73 = v47.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v20, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), address(this), v69, v49, v65, v70, v50, v51).gas(msg.gas);
                            require(bool(v73), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x2437B0xa6f;
                        } else {
                            v20 = v74 = 0;
                            v43 = v75 = address(v22 >> 24);
                            v76 = new array[](v23.length);
                            v77 = v78 = 0;
                            while (v77 < v23.length) {
                                MEM[v77 + v76.data] = MEM[v77 + v23.data];
                                v77 += 32;
                            }
                            if (v77 <= v23.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x2437B0xa6f;
                            } else {
                                MEM[v23.length + v76.data] = 0;
                            }
                        }
                    } else {
                        v79 = new uint256[](1);
                        CALLDATACOPY(v79.data, msg.data.length, 32);
                        require(0 < v79.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v80 = v79.data;
                        v79[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = v21;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v43 = v83 = address(v22 >> 24);
                        v84 = new uint256[](v79.length);
                        v85 = v86 = v84.data;
                        v87 = v88 = v79.data;
                        v89 = v90 = 0;
                        while (v89 < v79.length) {
                            MEM[v85] = address(MEM[v87]);
                            v85 += 32;
                            v87 += 32;
                            v89 += 1;
                        }
                        MEM[v85] = v81.length;
                        v91 = v92 = v85 + 32;
                        v93 = v94 = v81.data;
                        v95 = v96 = 0;
                        while (v95 < v81.length) {
                            MEM[v91] = MEM[v93];
                            v91 += 32;
                            v93 += 32;
                            v95 += 1;
                        }
                        MEM[v91] = v23.length;
                        v97 = v98 = 0;
                        while (v97 < v23.length) {
                            MEM[v97 + (v91 + 32)] = MEM[v97 + v23.data];
                            v97 += 32;
                        }
                        if (v97 <= v23.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x2437B0xa6f;
                        } else {
                            MEM[v23.length + (v91 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x2437B0xa6f;
                    }
                    require(bool(v43.code.size));
                    v99 = v43.call(v84, v76, v61, v44, v20, v20, address(this), address(this), v84, v76, v61, v44, 1, v20, v85 - (4 + MEM[64]), address(this), address(this), v84, v76, v61, v44, v100, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v99), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v101 = new uint256[](1);
                    CALLDATACOPY(v101.data, msg.data.length, 32);
                    require(0 < v101.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v102 = v101.data;
                    v101[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = v21;
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = new uint256[](v101.length);
                    v107 = v108 = v106.data;
                    v109 = v110 = v101.data;
                    v111 = v112 = 0;
                    while (v111 < v101.length) {
                        MEM[v107] = address(MEM[v109]);
                        v107 += 32;
                        v109 += 32;
                        v111 += 1;
                    }
                    v107 = new uint256[](v103.length);
                    v113 = v114 = v107.data;
                    v115 = v116 = v103.data;
                    v117 = v118 = 0;
                    while (v117 < v103.length) {
                        MEM[v113] = MEM[v115];
                        v113 += 32;
                        v115 += 32;
                        v117 += 1;
                    }
                    v113 = new uint256[](v105.length);
                    v119 = v120 = v113.data;
                    v121 = v122 = v105.data;
                    v123 = v124 = 0;
                    while (v123 < v105.length) {
                        MEM[v119] = MEM[v121];
                        v119 += 32;
                        v121 += 32;
                        v123 += 1;
                    }
                    v119 = new array[](v23.length);
                    v125 = v126 = 0;
                    while (v125 < v23.length) {
                        MEM[v125 + v119.data] = MEM[v125 + v23.data];
                        v125 += 32;
                    }
                    if (v125 <= v23.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x2437B0xa6f;
                    } else {
                        MEM[v23.length + v119.data] = 0;
                    }
                    require(bool((address(v22 >> 24)).code.size));
                    v127 = address(v22 >> 24).flashLoan(address(this), v106, v107, v113, address(this), v119, uint16(0), v100, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v127), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x2437B0xa6f;
                }
                goto 0x50090x2437B0xa6f;
            } else {
                require(bool((address(v22 >> 24)).code.size));
                v128 = address(v22 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v21, this).gas(msg.gas);
                require(bool(v128), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v19 += 1;
    }
    if (msg.data[varg4.data + msg.data[varg4.data] + 128]) {
        0x20f3(msg.data[varg4.data + msg.data[varg4.data] + 128], msg.data[varg4.data + msg.data[varg4.data] + 32], msg.data[varg4.data + msg.data[varg4.data] + 64]);
    }
    v129 = v130 = 0;
    while (v129 < MEM[MEM[64]]) {
        require(v129 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v131 = v131 + MEM[32 + (v129 << 5) + MEM[64]];
        v129 += 1;
    }
    _refund = 'EXECUTION';
    v132 = new array[](MEM[MEM[64]]);
    v133 = v134 = 0;
    while (v133 < MEM[MEM[64]]) {
        MEM[v133 + v132.data] = MEM[v133 + (MEM[64] + 32)];
        v133 += 32;
    }
    if (v133 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x2437B0xa6f;
    } else {
        MEM[MEM[MEM[64]] + v132.data] = 0;
    }
    require(bool((address(varg4[msg.data[varg4.data]])).code.size));
    v135 = address(varg4[msg.data[varg4.data]]).call(0x7fe3ba8b, address(msg.data[varg4.data + msg.data[varg4.data] + 32]), v131, v132).gas(msg.gas);
    require(bool(v135), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v136 = v137 = 0;
    while (v136 < MEM[MEM[64]]) {
        require(v136 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v138 = v139 = MEM[32 + (v136 << 5) + MEM[64]];
        if (0 != v139) {
            require(v136 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v140 = v141 = bool(MEM[(v136 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v136 << 5) + MEM[64] + 32]) != 4) {
                v140 = bool(MEM[(v136 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v140) {
                if (bool(MEM[(v136 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v136 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v142 = address(MEM[(v136 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v142), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v138 = MEM[MEM[64]];
                }
                if (v138) {
                    0x20f3(v138, MEM[(v136 << 5) + MEM[64] + 32] >> 24, msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    if (bool(MEM[(v136 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v136 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v143 = address(MEM[(v136 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v143), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v139;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v136 << 5) + MEM[64] + 32] >> 24));
                v144 = v145 = 0;
                while (v144 < 68) {
                    MEM[v144 + MEM[64]] = MEM[v144 + (MEM[64] + 32)];
                    v144 += 32;
                }
                if (v144 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x2437B0xa6f;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v146 = v147 = address(msg.data[varg4.data + msg.data[varg4.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v148 = v149 = 96;
                } else {
                    v148 = v150 = MEM[64];
                    MEM[64] = v150 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v150] = RETURNDATASIZE();
                    RETURNDATACOPY(v150 + 32, 0, RETURNDATASIZE());
                }
                if (v147) {
                    v146 = v151 = !MEM[v148];
                    if (MEM[v148]) {
                        require(32 + v148 + MEM[v148] - (32 + v148) >= 32);
                        v146 = MEM[32 + v148];
                        require(v146 == bool(v146));
                    }
                }
                require(v146, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v136 += 1;
    }
    return 0x7968ba28153757de2da7bce4c2ba9ebaf94445061f3050de1b0de5c34bb7d5d8;
}

function 0x3e2af770(uint256 varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 <= 0xffffffffffffffff);
    require(4 + varg0 + 31 < msg.data.length);
    v0 = v1 = varg0.length;
    require(v1 <= 0xffffffffffffffff);
    require(4 + varg0 + (v1 << 5) + 32 <= msg.data.length);
    require(v1 <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
    v2 = new uint256[](v1);
    if (v1) {
        v3 = v2.data;
        do {
            MEM[MEM[64]] = 0;
            MEM[MEM[64] + 32] = 96;
            MEM[v3] = MEM[64];
            v3 += 32;
            v0 = v0 - 1;
        } while (!v0);
    }
    v4 = v5 = 0;
    while (v4 < v1) {
        require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
        require(varg0[v4 << 5][v4] + varg0.data + 32 - (varg0[v4 << 5][v4] + varg0.data) >= 32);
        require(varg0[varg0[v4 << 5][v4]] == address(varg0[varg0[v4 << 5][v4]]));
        require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
        require(msg.data[varg0[v4 << 5][v4] + varg0.data + 32] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
        require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] <= 0xffffffffffffffff);
        require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] << 5));
        require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
        v6 = new uint256[](msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]]);
        if (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]]) {
            CALLDATACOPY(v6.data, msg.data.length, msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] << 5);
        }
        require(v4 < v2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        MEM[32 + v2[v4]] = v6;
        v7 = 0x24ed(this, varg0[varg0[v4 << 5][v4]]);
        require(v4 < v2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        MEM[v2[v4]] = v7;
        v8 = v9 = 0;
        while (v4 >= v1) {
            require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
            require(msg.data[varg0[v4 << 5][v4] + varg0.data + 32] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
            require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] <= 0xffffffffffffffff);
            require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] << 5));
            if (v8 >= msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]]) {
                v4 = 0x3977(v4);
            } else {
                require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + 96] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]] <= 0xffffffffffffffff);
                require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]] << 5));
                require(v8 < msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + 32] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] <= 0xffffffffffffffff);
                require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]] << 5));
                require(v8 < msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32])) + 32 - ((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))) >= 32);
                require(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))] == address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))]));
                require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + 64] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
                require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] <= 0xffffffffffffffff);
                require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] << 5));
                v10 = v11 = msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] > v8;
                if (v11) {
                    require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
                    require(msg.data[varg0[v4 << 5][v4] + varg0.data + 64] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
                    require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] <= 0xffffffffffffffff);
                    require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] << 5));
                    require(v8 < msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64])) + 32 - ((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))) >= 32);
                    require(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))] == address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))]));
                    v10 = address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))]) != 0;
                }
                if (!v10) {
                    v12 = v13 = msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]))] == 4;
                    if (msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]))] != 4) {
                        v12 = msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]))] == 7;
                    }
                    if (!v12) {
                        if (msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]))] != 6) {
                            v14 = v15 = 0x24ed(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))], varg0[varg0[v4 << 5][v4]]);
                            v16 = v17 = msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 96]))] == 1;
                            if (v17) {
                                v16 = v15 > 0;
                            }
                            if (v16) {
                                v14 = v18 = _SafeSub(v15, 1);
                            }
                        } else {
                            require(bool((address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))])).code.size));
                            v19 = address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 32]))]).maxFlashLoan(address(varg0[varg0[v4 << 5][v4]])).gas(msg.gas);
                            require(bool(v19), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                            v14 = v20 = MEM[MEM[64]];
                        }
                    } else {
                        v14 = v21 = 0x204fce5e3e25026110000000;
                    }
                } else {
                    require(v4 < v1, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require(varg0[v4 << 5][v4] < msg.data.length - varg0.data + ~126);
                    require(msg.data[varg0[v4 << 5][v4] + varg0.data + 64] < msg.data.length - (varg0[v4 << 5][v4] + varg0.data) + ~30);
                    require(msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] <= 0xffffffffffffffff);
                    require(32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]) <= msg.data.length - (msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]] << 5));
                    require(v8 < msg.data[varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    require((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64])) + 32 - ((v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))) >= 32);
                    require(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))] == address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))]));
                    MEM[36 + MEM[64]] = address(msg.data[(v8 << 5) + (32 + (varg0[v4 << 5][v4] + varg0.data + msg.data[varg0[v4 << 5][v4] + varg0.data + 64]))]);
                    MEM[MEM[64] + 32] = uint224(MEM[MEM[64] + 32]) | 0x70a0823100000000000000000000000000000000000000000000000000000000;
                    v22 = v23 = 0;
                    while (v22 < 68 + MEM[64] - MEM[64] - 32) {
                        MEM[v22 + MEM[64]] = MEM[v22 + (MEM[64] + 32)];
                        v22 += 32;
                    }
                    if (v22 <= 68 + MEM[64] - MEM[64] - 32) {
                        goto 0x33aa0x3398B0x25210xaa9B0x358;
                    } else {
                        MEM[68 + MEM[64] - MEM[64] - 32 + MEM[64]] = 0;
                    }
                    v24 = v25 = address(varg0[varg0[v4 << 5][v4]]).staticcall(MEM[(MEM[64]) len (68 + MEM[64] - MEM[64] - 32 + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);
                    if (RETURNDATASIZE() == 0) {
                        v26 = 96;
                    } else {
                        v26 = v27 = MEM[64];
                        MEM[64] = v27 + (RETURNDATASIZE() + 63 & ~0x1f);
                        MEM[v27] = RETURNDATASIZE();
                        RETURNDATACOPY(v27 + 32, 0, RETURNDATASIZE());
                    }
                    if (v25) {
                        v24 = MEM[v26] >= 32;
                    }
                    require(v24);
                    require(32 + v26 + MEM[v26] - (32 + v26) >= 32);
                    v14 = MEM[32 + v26];
                }
                require(v4 < v2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require(v8 < MEM[MEM[32 + v2[v4]]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                MEM[32 + (v8 << 5) + MEM[32 + v2[v4]]] = v14;
                v8 = 0x3977(v8);
            }
        }
        revert(Panic(50));
    }
    v28 = new uint256[](v2.length);
    v29 = v30 = v28.data;
    v31 = v32 = MEM[64] + (v2.length << 5) + 64;
    v33 = v34 = v2.data;
    v35 = v36 = 0;
    while (v35 < v2.length) {
        MEM[v29] = ~63 + (v31 - MEM[64]);
        MEM[v31] = MEM[MEM[v33]];
        MEM[v31 + 32] = 64;
        MEM[v31 + 64] = MEM[MEM[32 + MEM[v33]]];
        v31 = v31 + 64 + 32;
        v37 = v38 = MEM[32 + MEM[v33]] + 32;
        v39 = v40 = 0;
        while (v39 < MEM[MEM[32 + MEM[v33]]]) {
            MEM[v31] = MEM[v37];
            v31 += 32;
            v37 += 32;
            v39 += 1;
        }
        v29 += 32;
        v33 += 32;
        v35 += 1;
    }
    return v28;
}

function executeOperation(address varg0, address varg1, uint256 varg2, uint256 varg3, bytes varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 == varg0);
    require(varg1 == address(varg1));
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= 0xffffffffffffffff);
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    0xf47(varg4.length, varg4.data, varg3, varg2, varg1, varg0);
}

function 0x3867(uint256 varg0) private { 
    require(varg0 <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
    return 32 + (varg0 << 5);
}

function 0x388a(uint256 varg0) private { 
    require(varg0 <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
    return 32 + (~0x1f & 31 + varg0);
}

function refund(address varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(_refund == keccak256(varg0, varg1), Error('BBVault: REFUND_PARAMETERS'));
    0x25d4(varg1, varg0);
}

function _SafeAdd(uint256 varg0, uint256 varg1) private { 
    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow
    return varg0 + varg1;
}

function _SafeSub(uint256 varg0, uint256 varg1) private { 
    require(varg0 >= varg1, Panic(17)); // arithmetic overflow or underflow
    return varg0 - varg1;
}

function 0x3977(uint256 varg0) private { 
    require(varg0 != ~0, Panic(17)); // arithmetic overflow or underflow
    return 1 + varg0;
}

//  Method: 512b7351
//  ------------
//  [000]: 0000000000000000000000008db0efee6a7622cd9f46a2cf1aedc8505341a1a7
//  [020]: 0000000000000000000000002f2a2543b76a4166549f7aab2e75bef0aefc5b0f
//  [040]: 000000000000000000000000000000000000000000000000000000003626be46
//  [060]: 00000000000000000000000000000000000000000000000000000000000000a0
//  [080]: 00000000000000000000000000000000000000000000000000000000000000e0
//  [0a0]: 0000000000000000000000000000000000000000000000000000000000000001
//  [0c0]: 0000000000000000000930c3aca019d2f311dd4b2ad2eede5bb1933661000004

//  [0e0]: 0000000000000000000000000000000000000000000000000000000000000200
//  [100]: 0000000000000000000000000000000000000000000000000000000000000060
//  [120]: 0000000000000000000000000000000000000000000000000000000000000180

//  [140]: 000000000000000005f39ee8000000000000000000000000000000000174d102

//  [160]: 0000000000000000000000000000000000000000000000000000000000000002
//  [180]: 000000000000000000000000c9b8a3fdecb9d5b218d02555a8baf332e5b740d5
//  [1a0]: 9ea522292ed9e3cc345bac4fbdbc199e638f8ad00000000000402000000640cb
//  [1c0]: 00000000000000000000000000000000000000005e0d443fddc1f59d04000401
//  [1e0]: 0000000000000000000000000000000000000000000053612a88be542fc54323

//  [200]: 000000000000000000000000489ee077994b6658eafa855c308275ead8097c4a
//  [220]: 9ea522292ed9e3cc345bac4fbdbc199e638f8ad0000000000060440000000093
//  [240]: 0000000000000000000000000000000000000000000000000000000500010612
//  [260]: 000000000000000000000000000000000000000000000000000000003626be46

//  [280]: 0000000000000000000000000000000000000000000000000000000000000003
//  [2a0]: 000000000000000000000000f1970a61a04b1ca14834a43f5de4533ebddb5cc8
//  [2c0]: 0000000000000000000000001270e7694d38f3f80e0e033703c1272a80b914fc
//  [2e0]: 0000000000000000000000001270e7694d38f3f80e0e033703c1272a80b914fc
// varg0 = 8db0efee6a7622cd9f46a2cf1aedc8505341a1a7
// varg1 = 0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f
// varg2 = 908,508,742 (000000000000000000000000000000000000000000000000000000003626be46)
// varg3 = [0000000000000000000930c3aca019d2f311dd4b2ad2eede5bb1933661000004]
// varg4 = 
// [
//     {
//         "a": "000000000000000005f39ee8000000000000000000000000000000000174d102",
//         "b": [
//             """
//             //  [180]: 000000000000000000000000c9b8a3fdecb9d5b218d02555a8baf332e5b740d5
//             //  [1a0]: 9ea522292ed9e3cc345bac4fbdbc199e638f8ad00000000000402000000640cb
//             //  [1c0]: 00000000000000000000000000000000000000005e0d443fddc1f59d04000401
//             //  [1e0]: 0000000000000000000000000000000000000000000053612a88be542fc54323
//             """,
//             """
//             //  [200]: 000000000000000000000000489ee077994b6658eafa855c308275ead8097c4a
//             //  [220]: 9ea522292ed9e3cc345bac4fbdbc199e638f8ad0000000000060440000000093
//             //  [240]: 0000000000000000000000000000000000000000000000000000000500010612
//             //  [260]: 000000000000000000000000000000000000000000000000000000003626be46
//             """
//         ],
//         "c": ["0xf1970a61a04b1ca14834a43f5de4533ebddb5cc8", "0x1270e7694d38f3f80e0e033703c1272a80b914fc", "0x1270e7694d38f3f80e0e033703c1272a80b914fc"]
//     }
// ]

function 0x512b7351(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 == varg0);
    require(varg1 == varg1);
    require(varg3 <= 0xffffffffffffffff);
    require(4 + varg3 + 31 < msg.data.length);
    require(varg3.length <= 0xffffffffffffffff);
    require(4 + varg3 + (varg3.length << 5) + 32 <= msg.data.length);
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= 0xffffffffffffffff);
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    v0 = v1 = _borrow[msg.sender] >= 1;
    // C1: ACL
    if (_borrow[msg.sender] >= 1) {
    // C2: refund=false (.refund())
        v0 = !_refund;
    }
    require(v0, Error('BBVault: FORBIDDEN'));
    v2 = 0x24ed(this, varg1);
    if (v2 < varg2) {
        require(varg3.length, Error('BBVault: INSUFFICIENT'));
        v3 = MEM[64];
        MEM[v3] = address(0x0);
        MEM[32 + v3] = address(0x0);
        MEM[64 + v3] = address(0x0);
        MEM[128 + v3] = 0;
        MEM[160 + v3] = 0;
        MEM[192 + v3] = 96;
        MEM[224 + v3] = 96;
        MEM[256 + v3] = 96;
        v4 = new bytes[](varg4.length);
        CALLDATACOPY(v4.data, varg4.data, varg4.length);
        v4[varg4.length] = 0;
        if (v2) {
            v5 = v6 = v7 - v2;
        }
        require(varg3.length <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
        v8 = new uint256[](varg3.length);
        if (varg3.length) {
            CALLDATACOPY(v8.data, msg.data.length, varg3.length << 5);
        }
        v9 = v10 = 0;
        while (v9 < varg3.length) {
            require(v9 < varg3.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v11 = v12 = bool(varg3[v9 << 5][v9]) == 4;
            if (bool(varg3[v9 << 5][v9]) != 4) {
                v11 = bool(varg3[v9 << 5][v9]) == 7;
            }
            if (!v11) {
                if (bool(varg3[v9 << 5][v9]) != 6) {
                    v5 = v13 = 0x24ed(varg3[v9 << 5][v9] >> 24, varg1);
                    v14 = v15 = bool(varg3[v9 << 5][v9]) == 1;
                    if (v15) {
                        v14 = v13 > 0;
                    }
                    if (v14) {
                        v5 = v16 = ~0 + v13;
                    }
                } else {
                    require(bool((address(varg3[v9 << 5][v9] >> 24)).code.size));
                    v17 = address(varg3[v9 << 5][v9] >> 24).maxFlashLoan(varg1).gas(msg.gas);
                    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v5 = MEM[MEM[64]];
                }
            }
            if (v5) {
                v5 = v5 - v5;
                require(v9 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v8[v9] = v5;
                if (!v5) {
                    break;
                }
            }
            v9 += 1;
        }
        require(!v5, Error('BBVault: INSUFFICIENT'));
        v18 = new uint256[](varg3.length);
        CALLDATACOPY(v18.data, varg3.data, varg3.length << 5);
        v18[varg3.length] = 0;
        while (v19 < MEM[v18]) {
            require(v19 < MEM[v8], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v20 = v21 = MEM[32 + (v19 << 5) + v8];
            if (0 != v21) {
                require(v19 < MEM[v18], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v22 = MEM[32 + (v19 << 5) + v18];
                if (uint8(bool(v22)) != 3) {
                    v23 = new array[](32 + ((~0x1f & 31 + MEM[v4]) + v24) - MEM[64] + ~31);
                    MEM[v23.data] = 32;
                    MEM[v23.data + 32] = msg.sender;
                    MEM[v23.data + 64] = varg0;
                    MEM[v23.data + 96] = varg1;
                    MEM[v23.data + 128] = v19;
                    MEM[v23.data + 160] = varg2;
                    MEM[v23.data + 192] = v2;
                    MEM[v23.data + 224] = 288;
                    MEM[v23.data + 320] = MEM[v18];
                    v25 = v26 = v23.data + 320 + 32;
                    v27 = v28 = v18 + 32;
                    v29 = v30 = 0;
                    while (v29 < MEM[v18]) {
                        MEM[v25] = MEM[v27];
                        v25 += 32;
                        v27 += 32;
                        v29 += 1;
                    }
                    MEM[v23.data + 256] = v25 - v23.data + ~31;
                    MEM[v25] = MEM[v8];
                    v24 = v31 = v25 + 32;
                    v32 = v33 = v8 + 32;
                    v34 = v35 = 0;
                    while (v34 < MEM[v8]) {
                        MEM[v24] = MEM[v32];
                        v24 += 32;
                        v32 += 32;
                        v34 += 1;
                    }
                    MEM[v23.data + 288] = ~31 + (v24 - v23.data);
                    MEM[v24] = MEM[v4];
                    v36 = v37 = 0;
                    while (v36 < MEM[v4]) {
                        MEM[v36 + (v24 + 32)] = MEM[v36 + (v4 + 32)];
                        v36 += 32;
                    }
                    if (v36 <= MEM[v4]) {
                        goto 0x3374B0x3766B0x1b5aB0x6ddB0x11d8B0x3c5;
                    } else {
                        MEM[MEM[v4] + (v24 + 32)] = 0;
                    }
                    v38 = v23.length;
                    v39 = v23.data;
                    _refund = keccak256(v23);
                    if (bool(v22) != 4) {
                        if (bool(v22) != 9) {
                            if (bool(v22) != 10) {
                                v40 = v41 = bool(v22) == 5;
                                if (bool(v22) != 5) {
                                    v40 = v42 = bool(v22) == 7;
                                }
                                if (!v40) {
                                    v40 = bool(v22) == 11;
                                }
                                if (!v40) {
                                    if (bool(v22) != 12) {
                                        if (bool(v22) != 2) {
                                            if (bool(v22) != 6) {
                                                if (bool(v22) != 8) {
                                                    require(bool(v22) == 1, Error('BBVault: TYPE'));
                                                    v20 = 0;
                                                    v43 = address(v22 >> 24);
                                                    v44 = new array[](v23.length);
                                                    v45 = v46 = 0;
                                                    while (v45 < v23.length) {
                                                        MEM[v45 + v44.data] = MEM[v45 + v23.data];
                                                        v45 += 32;
                                                    }
                                                    if (v45 <= v23.length) {
                                                        goto 0x3374B0x3782B0x2089B0x6ddB0x11d8B0x3c5;
                                                    } else {
                                                        MEM[v23.length + v44.data] = 0;
                                                    }
                                                    goto 0x1db9B0x6ddB0x11d8B0x3c5;
                                                } else {
                                                    v47 = v48 = address(v22 >> 24);
                                                    v49 = new array[](v21);
                                                    v50 = new array[](160);
                                                    v51 = new array[](v23.length);
                                                    v52 = v53 = 0;
                                                    while (v52 < v23.length) {
                                                        MEM[v52 + v51.data] = MEM[v52 + v23.data];
                                                        v52 += 32;
                                                    }
                                                    if (v52 <= v23.length) {
                                                        goto 0x3374B0x33b4B0x203bB0x6ddB0x11d8B0x3c5;
                                                    } else {
                                                        MEM[v23.length + v51.data] = 0;
                                                    }
                                                    goto 0x1e8fB0x6ddB0x11d8B0x3c5;
                                                }
                                            } else {
                                                v54 = new array[](v23.length);
                                                v55 = v56 = 0;
                                                while (v55 < v23.length) {
                                                    MEM[v55 + v54.data] = MEM[v55 + v23.data];
                                                    v55 += 32;
                                                }
                                                if (v55 <= v23.length) {
                                                    goto 0x3374B0x33faB0x1f63B0x6ddB0x11d8B0x3c5;
                                                } else {
                                                    MEM[v23.length + v54.data] = 0;
                                                }
                                                require(bool((address(v22 >> 24)).code.size));
                                                v57, /* bool */ v58 = address(v22 >> 24).flashLoan(address(this), varg1, v21, v54).gas(msg.gas);
                                                require(bool(v57), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                                require(v58 == bool(v58));
                                                require(v58, Error('Vault: ERC3156_FALSE'));
                                                goto 0x4a12B0x11d8B0x3c5;
                                            }
                                        } else {
                                            v20 = v59 = 0;
                                            v43 = v60 = address(v22 >> 24);
                                            v61 = new array[](v23.length);
                                            v62 = v63 = 0;
                                            while (v62 < v23.length) {
                                                MEM[v62 + v61.data] = MEM[v62 + v23.data];
                                                v62 += 32;
                                            }
                                            if (v62 <= v23.length) {
                                                goto 0x3374B0x3782B0x1f27B0x6ddB0x11d8B0x3c5;
                                            } else {
                                                MEM[v23.length + v61.data] = 0;
                                            }
                                            goto 0x1db9B0x6ddB0x11d8B0x3c5;
                                        }
                                    } else {
                                        if (v22 & 0x10) {
                                            v20 = v64 = v21 << 128;
                                        }
                                        v47 = address(v22 >> 24);
                                        v65 = new array[](v23.length);
                                        v66 = v67 = 0;
                                        while (v66 < v23.length) {
                                            MEM[v66 + v65.data] = MEM[v66 + v23.data];
                                            v66 += 32;
                                        }
                                        if (v66 <= v23.length) {
                                            goto 0x3374B0x34ffB0x1ee0B0x6ddB0x11d8B0x3c5;
                                        } else {
                                            MEM[v23.length + v65.data] = 0;
                                        }
                                        goto 0x1e8fB0x6ddB0x11d8B0x3c5;
                                    }
                                } else {
                                    v47 = v68 = address(v22 >> 24);
                                    v69 = new array[](128);
                                    v70 = new array[](v23.length);
                                    v71 = v72 = 0;
                                    while (v71 < v23.length) {
                                        MEM[v71 + v70.data] = MEM[v71 + v23.data];
                                        v71 += 32;
                                    }
                                    if (v71 <= v23.length) {
                                        goto 0x3374B0x33faB0x1e5bB0x6ddB0x11d8B0x3c5;
                                    } else {
                                        MEM[v23.length + v70.data] = 0;
                                    }
                                }
                                require(bool(v47.code.size));
                                v73 = v47.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v20, varg1, address(this), v69, v49, v65, v70, v50, v51).gas(msg.gas);
                                require(bool(v73), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                goto 0x4a12B0x11d8B0x3c5;
                            } else {
                                v20 = v74 = 0;
                                v43 = v75 = address(v22 >> 24);
                                v76 = new array[](v23.length);
                                v77 = v78 = 0;
                                while (v77 < v23.length) {
                                    MEM[v77 + v76.data] = MEM[v77 + v23.data];
                                    v77 += 32;
                                }
                                if (v77 <= v23.length) {
                                    goto 0x3374B0x356eB0x1e09B0x6ddB0x11d8B0x3c5;
                                } else {
                                    MEM[v23.length + v76.data] = 0;
                                }
                            }
                        } else {
                            v79 = new uint256[](1);
                            CALLDATACOPY(v79.data, msg.data.length, 32);
                            require(0 < v79.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                            v80 = v79.data;
                            v79[0] = varg1;
                            v81 = new uint256[](1);
                            CALLDATACOPY(v81.data, msg.data.length, 32);
                            require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                            v82 = v81.data;
                            v81[0] = v21;
                            MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                            v43 = v83 = address(v22 >> 24);
                            v84 = new uint256[](v79.length);
                            v85 = v86 = v84.data;
                            v87 = v88 = v79.data;
                            v89 = v90 = 0;
                            while (v89 < v79.length) {
                                MEM[v85] = address(MEM[v87]);
                                v85 += 32;
                                v87 += 32;
                                v89 += 1;
                            }
                            MEM[v85] = v81.length;
                            v91 = v92 = v85 + 32;
                            v93 = v94 = v81.data;
                            v95 = v96 = 0;
                            while (v95 < v81.length) {
                                MEM[v91] = MEM[v93];
                                v91 += 32;
                                v93 += 32;
                                v95 += 1;
                            }
                            MEM[v91] = v23.length;
                            v97 = v98 = 0;
                            while (v97 < v23.length) {
                                MEM[v97 + (v91 + 32)] = MEM[v97 + v23.data];
                                v97 += 32;
                            }
                            if (v97 <= v23.length) {
                                goto 0x3374B0x34ebB0x1d7cB0x6ddB0x11d8B0x3c5;
                            } else {
                                MEM[v23.length + (v91 + 32)] = 0;
                            }
                            goto 0x1db9B0x6ddB0x11d8B0x3c5;
                        }
                        require(bool(v43.code.size));
                        v99 = v43.call(v84, v76, v61, v44, v20, v20, address(this), address(this), v84, v76, v61, v44, 1, v20, v85 - (4 + MEM[64]), address(this), address(this), v84, v76, v61, v44, v100, varg1).gas(msg.gas);
                        require(bool(v99), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    } else {
                        v101 = new uint256[](1);
                        CALLDATACOPY(v101.data, msg.data.length, 32);
                        require(0 < v101.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v102 = v101.data;
                        v101[0] = varg1;
                        v103 = new uint256[](1);
                        CALLDATACOPY(v103.data, msg.data.length, 32);
                        require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v104 = v103.data;
                        v103[0] = v21;
                        CALLDATACOPY(v105.data, msg.data.length, 32);
                        require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v106 = new uint256[](v101.length);
                        v107 = v108 = v106.data;
                        v109 = v110 = v101.data;
                        v111 = v112 = 0;
                        while (v111 < v101.length) {
                            MEM[v107] = address(MEM[v109]);
                            v107 += 32;
                            v109 += 32;
                            v111 += 1;
                        }
                        v107 = new uint256[](v103.length);
                        v113 = v114 = v107.data;
                        v115 = v116 = v103.data;
                        v117 = v118 = 0;
                        while (v117 < v103.length) {
                            MEM[v113] = MEM[v115];
                            v113 += 32;
                            v115 += 32;
                            v117 += 1;
                        }
                        v113 = new uint256[](v105.length);
                        v119 = v120 = v113.data;
                        v121 = v122 = v105.data;
                        v123 = v124 = 0;
                        while (v123 < v105.length) {
                            MEM[v119] = MEM[v121];
                            v119 += 32;
                            v121 += 32;
                            v123 += 1;
                        }
                        v119 = new array[](v23.length);
                        v125 = v126 = 0;
                        while (v125 < v23.length) {
                            MEM[v125 + v119.data] = MEM[v125 + v23.data];
                            v125 += 32;
                        }
                        if (v125 <= v23.length) {
                            goto 0x3374B0x347fB0x6ddB0x11d8B0x3c5;
                        } else {
                            MEM[v23.length + v119.data] = 0;
                        }
                        require(bool((address(v22 >> 24)).code.size));
                        v127 = address(v22 >> 24).flashLoan(address(this), v106, v107, v113, address(this), v119, uint16(0), v100, varg1).gas(msg.gas);
                        require(bool(v127), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                        goto 0x4a12B0x11d8B0x3c5;
                    }
                    goto 0x11e1B0x3c5;
                } else {
                    require(bool((address(v22 >> 24)).code.size));
                    v128 = address(v22 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, varg1, v21, this).gas(msg.gas);
                    require(bool(v128), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                }
            }
            v19 += 1;
        }
        if (varg2) {
            0x20f3(varg2, varg0, varg1);
        }
        v129 = v130 = 0;
        while (v129 < MEM[v18]) {
            require(v129 < MEM[v8], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v131 = v131 + MEM[32 + (v129 << 5) + v8];
            v129 += 1;
        }
        _refund = 'EXECUTION';
        v132 = new array[](MEM[v4]);
        v133 = v134 = 0;
        while (v133 < MEM[v4]) {
            MEM[v133 + v132.data] = MEM[v133 + (v4 + 32)];
            v133 += 32;
        }
        if (v133 <= MEM[v4]) {
            goto 0x3374B0x34ffB0x75bB0x11d8B0x3c5;
        } else {
            MEM[MEM[v4] + v132.data] = 0;
        }
        require(bool((address(msg.sender)).code.size));
        v135 = msg.sender.call(0x7fe3ba8b, varg0, v131, v132).gas(msg.gas);
        require(bool(v135), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
        v136 = v137 = 0;
        while (v136 < MEM[v18]) {
            require(v136 < MEM[v8], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v138 = v139 = MEM[32 + (v136 << 5) + v8];
            if (0 != v139) {
                require(v136 < MEM[v18], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                v140 = v141 = bool(MEM[(v136 << 5) + v18 + 32]) == 4;
                if (bool(MEM[(v136 << 5) + v18 + 32]) != 4) {
                    v140 = bool(MEM[(v136 << 5) + v18 + 32]) == 6;
                }
                if (!v140) {
                    if (bool(MEM[(v136 << 5) + v18 + 32]) == 3) {
                        require(bool((address(MEM[(v136 << 5) + v18 + 32] >> 24)).code.size));
                        v142 = address(MEM[(v136 << 5) + v18 + 32] >> 24).refundAmount().gas(msg.gas);
                        require(bool(v142), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                        v138 = MEM[MEM[64]];
                    }
                    if (v138) {
                        0x20f3(v138, MEM[(v136 << 5) + v18 + 32] >> 24, varg1);
                        if (bool(MEM[(v136 << 5) + v18 + 32]) == 3) {
                            require(bool((address(MEM[(v136 << 5) + v18 + 32] >> 24)).code.size));
                            v143 = address(MEM[(v136 << 5) + v18 + 32] >> 24).refund().gas(msg.gas);
                            require(bool(v143), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                        }
                    }
                } else {
                    MEM[MEM[64] + 68] = v139;
                    MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v136 << 5) + v18 + 32] >> 24));
                    v144 = v145 = 0;
                    while (v144 < 68) {
                        MEM[v144 + MEM[64]] = MEM[v144 + (MEM[64] + 32)];
                        v144 += 32;
                    }
                    if (v144 <= 68) {
                        goto 0x33aa0x3398B0x2207B0x853B0x11d8B0x3c5;
                    } else {
                        MEM[68 + MEM[64]] = 0;
                    }
                    v146 = v147 = varg1.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                    if (RETURNDATASIZE() == 0) {
                        v148 = v149 = 96;
                    } else {
                        v148 = v150 = MEM[64];
                        MEM[64] = v150 + (RETURNDATASIZE() + 63 & ~0x1f);
                        MEM[v150] = RETURNDATASIZE();
                        RETURNDATACOPY(v150 + 32, 0, RETURNDATASIZE());
                    }
                    if (v147) {
                        v146 = v151 = !MEM[v148];
                        if (MEM[v148]) {
                            require(32 + v148 + MEM[v148] - (32 + v148) >= 32);
                            v146 = MEM[32 + v148];
                            require(v146 == bool(v146));
                        }
                    }
                    require(v146, Error('BBVault: APPROVE_FAILED'));
                }
            }
            v136 += 1;
        }
    } else {
        0x20f3(varg2, varg0, varg1);
        _refund = 'EXECUTION';
        v152 = new array[](varg4.length);
        MEM[128 + (varg4.length + (4 + MEM[64]))] = 0;
        require(bool(msg.sender.code.size));
        v153 = msg.sender.call(0x7fe3ba8b, varg0, varg2, v152).gas(msg.gas);
        require(bool(v153), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    }
    require(_refund == 'EXECUTION', Error('BBVault: STATUS'));
    0x25d4(v2, varg1);
}

function borrow(address varg0, address varg1, uint256 varg2) public nonPayable { 
    require(msg.data.length - 4 >= 96);
    require(varg0 == varg0);
    require(varg1 == varg1);
    v0 = v1 = 2 <= _borrow[msg.sender];
    if (2 <= _borrow[msg.sender]) {
        v0 = v2 = !_refund;
    }
    require(v0, Error('BBVault: FORBIDDEN'));
    v3 = 0x24ed(this, varg1);
    0x20f3(varg2, varg0, varg1);
    _refund = keccak256(varg1, v3);
    return v3;
}

function 0x5dbacec5(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 == varg0);
    require(varg1 == varg1);
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= 0xffffffffffffffff);
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    CALLDATACOPY(v0.data, varg4.data, varg4.length);
    MEM[varg4.length + v0.data] = 0;
    require(_refund == keccak256(v0.data), Error('BBVault: STATUS'));
    require(varg4.data + varg4.length - varg4.data >= 32);
    require(msg.data[varg4.data] <= 0xffffffffffffffff);
    require(varg4.data + varg4.length - (varg4.data + msg.data[varg4.data]) >= 288);
    v1 = MEM[64];
    require(!((v1 + 288 < v1) | (v1 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v1 + 288;
    require(varg4[msg.data[varg4.data]] == address(varg4[msg.data[varg4.data]]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 32] == address(msg.data[varg4.data + msg.data[varg4.data] + 32]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 64] == address(msg.data[varg4.data + msg.data[varg4.data] + 64]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 192] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 31 < varg4.data + varg4.length);
    v2 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v2 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v2 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v2 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]];
    v3 = v4 = MEM[64] + 32;
    v5 = v6 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]] << 5) + 32 <= varg4.data + varg4.length);
    v7 = v8 = 0;
    while (v7 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]) {
        MEM[v3] = msg.data[v5];
        v3 += 32;
        v5 += 32;
        v7 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 224] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 31 < varg4.data + varg4.length);
    v9 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v9 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v9 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v9 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]];
    v10 = v11 = MEM[64] + 32;
    v12 = v13 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]] << 5) + 32 <= varg4.data + varg4.length);
    v14 = v15 = 0;
    while (v14 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]) {
        MEM[v10] = msg.data[v12];
        v10 += 32;
        v12 += 32;
        v14 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 256] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 31 < varg4.data + varg4.length);
    v16 = 0x388a(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v16 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v16 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v16 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]];
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]] + 32 <= varg4.data + varg4.length);
    CALLDATACOPY(MEM[64] + 32, varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 32, msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]])] = 0;
    if (!varg2) {
        require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v17 = MEM[32 + (msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64]];
    }
    v18 = _SafeAdd(v17, varg3);
    require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64] + 32] = v18;
    while (v19 < MEM[MEM[64]]) {
        require(v19 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v20 = v21 = MEM[32 + (v19 << 5) + MEM[64]];
        if (0 != v21) {
            require(v19 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v22 = MEM[32 + (v19 << 5) + MEM[64]];
            if (uint8(bool(v22)) != 3) {
                v23 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v24) - MEM[64] + ~31);
                MEM[v23.data] = 32;
                MEM[v23.data + 32] = address(varg4[msg.data[varg4.data]]);
                MEM[v23.data + 64] = address(msg.data[varg4.data + msg.data[varg4.data] + 32]);
                MEM[v23.data + 96] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                MEM[v23.data + 128] = v19;
                MEM[v23.data + 160] = msg.data[varg4.data + msg.data[varg4.data] + 128];
                MEM[v23.data + 192] = msg.data[varg4.data + msg.data[varg4.data] + 160];
                MEM[v23.data + 224] = 288;
                MEM[v23.data + 320] = MEM[MEM[64]];
                v25 = v26 = v23.data + 320 + 32;
                v27 = v28 = MEM[64] + 32;
                v29 = v30 = 0;
                while (v29 < MEM[MEM[64]]) {
                    MEM[v25] = MEM[v27];
                    v25 += 32;
                    v27 += 32;
                    v29 += 1;
                }
                MEM[v23.data + 256] = v25 - v23.data + ~31;
                MEM[v25] = MEM[MEM[64]];
                v24 = v31 = v25 + 32;
                v32 = v33 = MEM[64] + 32;
                v34 = v35 = 0;
                while (v34 < MEM[MEM[64]]) {
                    MEM[v24] = MEM[v32];
                    v24 += 32;
                    v32 += 32;
                    v34 += 1;
                }
                MEM[v23.data + 288] = ~31 + (v24 - v23.data);
                MEM[v24] = MEM[MEM[64]];
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v36 + (v24 + 32)] = MEM[v36 + (MEM[64] + 32)];
                    v36 += 32;
                }
                if (v36 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x2437B0x12ab;
                } else {
                    MEM[MEM[MEM[64]] + (v24 + 32)] = 0;
                }
                v38 = v23.length;
                v39 = v23.data;
                _refund = keccak256(v23);
                if (bool(v22) != 4) {
                    if (bool(v22) != 9) {
                        if (bool(v22) != 10) {
                            v40 = v41 = bool(v22) == 5;
                            if (bool(v22) != 5) {
                                v40 = v42 = bool(v22) == 7;
                            }
                            if (!v40) {
                                v40 = bool(v22) == 11;
                            }
                            if (!v40) {
                                if (bool(v22) != 12) {
                                    if (bool(v22) != 2) {
                                        if (bool(v22) != 6) {
                                            if (bool(v22) != 8) {
                                                require(bool(v22) == 1, Error('BBVault: TYPE'));
                                                v20 = 0;
                                                v43 = address(v22 >> 24);
                                                v44 = new array[](v23.length);
                                                v45 = v46 = 0;
                                                while (v45 < v23.length) {
                                                    MEM[v45 + v44.data] = MEM[v45 + v23.data];
                                                    v45 += 32;
                                                }
                                                if (v45 <= v23.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x2437B0x12ab;
                                                } else {
                                                    MEM[v23.length + v44.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x2437B0x12ab;
                                            } else {
                                                v47 = v48 = address(v22 >> 24);
                                                v49 = new array[](v21);
                                                v50 = new array[](160);
                                                v51 = new array[](v23.length);
                                                v52 = v53 = 0;
                                                while (v52 < v23.length) {
                                                    MEM[v52 + v51.data] = MEM[v52 + v23.data];
                                                    v52 += 32;
                                                }
                                                if (v52 <= v23.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x2437B0x12ab;
                                                } else {
                                                    MEM[v23.length + v51.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x2437B0x12ab;
                                            }
                                        } else {
                                            v54 = new array[](v23.length);
                                            v55 = v56 = 0;
                                            while (v55 < v23.length) {
                                                MEM[v55 + v54.data] = MEM[v55 + v23.data];
                                                v55 += 32;
                                            }
                                            if (v55 <= v23.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x2437B0x12ab;
                                            } else {
                                                MEM[v23.length + v54.data] = 0;
                                            }
                                            require(bool((address(v22 >> 24)).code.size));
                                            v57, /* bool */ v58 = address(v22 >> 24).flashLoan(address(this), address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v21, v54).gas(msg.gas);
                                            require(bool(v57), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v58 == bool(v58));
                                            require(v58, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x2437B0x12ab;
                                        }
                                    } else {
                                        v20 = v59 = 0;
                                        v43 = v60 = address(v22 >> 24);
                                        v61 = new array[](v23.length);
                                        v62 = v63 = 0;
                                        while (v62 < v23.length) {
                                            MEM[v62 + v61.data] = MEM[v62 + v23.data];
                                            v62 += 32;
                                        }
                                        if (v62 <= v23.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x2437B0x12ab;
                                        } else {
                                            MEM[v23.length + v61.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x2437B0x12ab;
                                    }
                                } else {
                                    if (v22 & 0x10) {
                                        v20 = v64 = v21 << 128;
                                    }
                                    v47 = address(v22 >> 24);
                                    v65 = new array[](v23.length);
                                    v66 = v67 = 0;
                                    while (v66 < v23.length) {
                                        MEM[v66 + v65.data] = MEM[v66 + v23.data];
                                        v66 += 32;
                                    }
                                    if (v66 <= v23.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x2437B0x12ab;
                                    } else {
                                        MEM[v23.length + v65.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x2437B0x12ab;
                                }
                            } else {
                                v47 = v68 = address(v22 >> 24);
                                v69 = new array[](128);
                                v70 = new array[](v23.length);
                                v71 = v72 = 0;
                                while (v71 < v23.length) {
                                    MEM[v71 + v70.data] = MEM[v71 + v23.data];
                                    v71 += 32;
                                }
                                if (v71 <= v23.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x2437B0x12ab;
                                } else {
                                    MEM[v23.length + v70.data] = 0;
                                }
                            }
                            require(bool(v47.code.size));
                            v73 = v47.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v20, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), address(this), v69, v49, v65, v70, v50, v51).gas(msg.gas);
                            require(bool(v73), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x2437B0x12ab;
                        } else {
                            v20 = v74 = 0;
                            v43 = v75 = address(v22 >> 24);
                            v76 = new array[](v23.length);
                            v77 = v78 = 0;
                            while (v77 < v23.length) {
                                MEM[v77 + v76.data] = MEM[v77 + v23.data];
                                v77 += 32;
                            }
                            if (v77 <= v23.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x2437B0x12ab;
                            } else {
                                MEM[v23.length + v76.data] = 0;
                            }
                        }
                    } else {
                        v79 = new uint256[](1);
                        CALLDATACOPY(v79.data, msg.data.length, 32);
                        require(0 < v79.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v80 = v79.data;
                        v79[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = v21;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v43 = v83 = address(v22 >> 24);
                        v84 = new uint256[](v79.length);
                        v85 = v86 = v84.data;
                        v87 = v88 = v79.data;
                        v89 = v90 = 0;
                        while (v89 < v79.length) {
                            MEM[v85] = address(MEM[v87]);
                            v85 += 32;
                            v87 += 32;
                            v89 += 1;
                        }
                        MEM[v85] = v81.length;
                        v91 = v92 = v85 + 32;
                        v93 = v94 = v81.data;
                        v95 = v96 = 0;
                        while (v95 < v81.length) {
                            MEM[v91] = MEM[v93];
                            v91 += 32;
                            v93 += 32;
                            v95 += 1;
                        }
                        MEM[v91] = v23.length;
                        v97 = v98 = 0;
                        while (v97 < v23.length) {
                            MEM[v97 + (v91 + 32)] = MEM[v97 + v23.data];
                            v97 += 32;
                        }
                        if (v97 <= v23.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x2437B0x12ab;
                        } else {
                            MEM[v23.length + (v91 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x2437B0x12ab;
                    }
                    require(bool(v43.code.size));
                    v99 = v43.call(v84, v76, v61, v44, v20, v20, address(this), address(this), v84, v76, v61, v44, 1, v20, v85 - (4 + MEM[64]), address(this), address(this), v84, v76, v61, v44, v100, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v99), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v101 = new uint256[](1);
                    CALLDATACOPY(v101.data, msg.data.length, 32);
                    require(0 < v101.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v102 = v101.data;
                    v101[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = v21;
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = new uint256[](v101.length);
                    v107 = v108 = v106.data;
                    v109 = v110 = v101.data;
                    v111 = v112 = 0;
                    while (v111 < v101.length) {
                        MEM[v107] = address(MEM[v109]);
                        v107 += 32;
                        v109 += 32;
                        v111 += 1;
                    }
                    v107 = new uint256[](v103.length);
                    v113 = v114 = v107.data;
                    v115 = v116 = v103.data;
                    v117 = v118 = 0;
                    while (v117 < v103.length) {
                        MEM[v113] = MEM[v115];
                        v113 += 32;
                        v115 += 32;
                        v117 += 1;
                    }
                    v113 = new uint256[](v105.length);
                    v119 = v120 = v113.data;
                    v121 = v122 = v105.data;
                    v123 = v124 = 0;
                    while (v123 < v105.length) {
                        MEM[v119] = MEM[v121];
                        v119 += 32;
                        v121 += 32;
                        v123 += 1;
                    }
                    v119 = new array[](v23.length);
                    v125 = v126 = 0;
                    while (v125 < v23.length) {
                        MEM[v125 + v119.data] = MEM[v125 + v23.data];
                        v125 += 32;
                    }
                    if (v125 <= v23.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x2437B0x12ab;
                    } else {
                        MEM[v23.length + v119.data] = 0;
                    }
                    require(bool((address(v22 >> 24)).code.size));
                    v127 = address(v22 >> 24).flashLoan(address(this), v106, v107, v113, address(this), v119, uint16(0), v100, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v127), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x2437B0x12ab;
                }
                goto 0x50090x2437B0x12ab;
            } else {
                require(bool((address(v22 >> 24)).code.size));
                v128 = address(v22 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v21, this).gas(msg.gas);
                require(bool(v128), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v19 += 1;
    }
    if (msg.data[varg4.data + msg.data[varg4.data] + 128]) {
        0x20f3(msg.data[varg4.data + msg.data[varg4.data] + 128], msg.data[varg4.data + msg.data[varg4.data] + 32], msg.data[varg4.data + msg.data[varg4.data] + 64]);
    }
    v129 = v130 = 0;
    while (v129 < MEM[MEM[64]]) {
        require(v129 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v131 = v131 + MEM[32 + (v129 << 5) + MEM[64]];
        v129 += 1;
    }
    _refund = 'EXECUTION';
    v132 = new array[](MEM[MEM[64]]);
    v133 = v134 = 0;
    while (v133 < MEM[MEM[64]]) {
        MEM[v133 + v132.data] = MEM[v133 + (MEM[64] + 32)];
        v133 += 32;
    }
    if (v133 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x2437B0x12ab;
    } else {
        MEM[MEM[MEM[64]] + v132.data] = 0;
    }
    require(bool((address(varg4[msg.data[varg4.data]])).code.size));
    v135 = address(varg4[msg.data[varg4.data]]).call(0x7fe3ba8b, address(msg.data[varg4.data + msg.data[varg4.data] + 32]), v131, v132).gas(msg.gas);
    require(bool(v135), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v136 = v137 = 0;
    while (v136 < MEM[MEM[64]]) {
        require(v136 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v138 = v139 = MEM[32 + (v136 << 5) + MEM[64]];
        if (0 != v139) {
            require(v136 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v140 = v141 = bool(MEM[(v136 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v136 << 5) + MEM[64] + 32]) != 4) {
                v140 = bool(MEM[(v136 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v140) {
                if (bool(MEM[(v136 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v136 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v142 = address(MEM[(v136 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v142), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v138 = MEM[MEM[64]];
                }
                if (v138) {
                    0x20f3(v138, MEM[(v136 << 5) + MEM[64] + 32] >> 24, msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    if (bool(MEM[(v136 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v136 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v143 = address(MEM[(v136 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v143), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v139;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v136 << 5) + MEM[64] + 32] >> 24));
                v144 = v145 = 0;
                while (v144 < 68) {
                    MEM[v144 + MEM[64]] = MEM[v144 + (MEM[64] + 32)];
                    v144 += 32;
                }
                if (v144 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x2437B0x12ab;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v146 = v147 = address(msg.data[varg4.data + msg.data[varg4.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v148 = v149 = 96;
                } else {
                    v148 = v150 = MEM[64];
                    MEM[64] = v150 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v150] = RETURNDATASIZE();
                    RETURNDATACOPY(v150 + 32, 0, RETURNDATASIZE());
                }
                if (v147) {
                    v146 = v151 = !MEM[v148];
                    if (MEM[v148]) {
                        require(32 + v148 + MEM[v148] - (32 + v148) >= 32);
                        v146 = MEM[32 + v148];
                        require(v146 == bool(v146));
                    }
                }
                require(v146, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v136 += 1;
    }
    return 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9;
}

function 0x61b9f8d0(uint256 varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 <= 0xffffffffffffffff);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= 0xffffffffffffffff);
    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    require(varg0.length, Error('BBVault: NoReceiver'));
    require(varg0.length <= 0xffffffffffffffff, Panic(65)); // failed memory allocation (too much memory)
    v0 = new uint256[](varg0.length);
    if (varg0.length) {
        CALLDATACOPY(v0.data, msg.data.length, varg0.length << 5);
    }
    v1 = v2 = 0;
    while (v1 < varg0.length) {
        require(v1 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require((v1 << 5) + varg0.data + 32 - ((v1 << 5) + varg0.data) >= 32);
        require(varg0[v1 << 5][v1] == address(varg0[v1 << 5][v1]));
        if ((address(varg0[v1 << 5][v1])).balance < varg1) {
            v3 = _SafeSub(varg1, (address(varg0[v1 << 5][v1])).balance);
            require(v1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v0[v1] = v3;
            require(v1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v1 = _SafeAdd(v1, v0[v1]);
        }
        v1 = 0x3977(v1);
    }
    if (this.balance < v1) {
        v4 = 0x24ed(this, 0x82af49447d8a07e3bd95bd0d56f35241523fbab1);
        v5 = _SafeSub(v1, this.balance);
        require(v5 <= v4, Error('BBVault: AmountExceed'));
        require(bool((address(0x82af49447d8a07e3bd95bd0d56f35241523fbab1)).code.size));
        v6 = address(0x82af49447d8a07e3bd95bd0d56f35241523fbab1).withdraw(v5).gas(msg.gas);
        require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    }
    v7 = v8 = 0;
    while (v7 < varg0.length) {
        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        if (v0[v7] > 0) {
            require(v7 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            require((v7 << 5) + varg0.data + 32 - ((v7 << 5) + varg0.data) >= 32);
            require(varg0[v7 << 5][v7] == address(varg0[v7 << 5][v7]));
            require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v9 = address(varg0[v7 << 5][v7]).call().value(v0[v7]).gas(!v0[v7] * 2300);
            require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
        }
        v7 = 0x3977(v7);
    }
}

function withdrawAll(address[] varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 <= 0xffffffffffffffff);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= 0xffffffffffffffff);
    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    v0 = v1 = 0;
    while (v0 < varg0.length) {
        require(v0 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require((v0 << 5) + varg0.data + 32 - ((v0 << 5) + varg0.data) >= 32);
        require(varg0[v0 << 5][v0] == address(varg0[v0 << 5][v0]));
        if (address(varg0[v0 << 5][v0]) != 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) {
            require(v0 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            require((v0 << 5) + varg0.data + 32 - ((v0 << 5) + varg0.data) >= 32);
            require(varg0[v0 << 5][v0] == address(varg0[v0 << 5][v0]));
            v2 = v3 = 0;
            while (v2 < 36) {
                MEM[v2 + MEM[64]] = MEM[v2 + (MEM[64] + 32)];
                v2 += 32;
            }
            if (v2 <= 36) {
                goto 0x33aa0x3398B0x25210x15eaB0x445;
            } else {
                MEM[36 + MEM[64]] = 0;
            }
            v4 = v5 = address(varg0[v0 << 5][v0]).balanceOf(address(this)).gas(msg.gas);
            if (RETURNDATASIZE() == 0) {
                v6 = 96;
            } else {
                v6 = v7 = MEM[64];
                MEM[64] = v7 + (RETURNDATASIZE() + 63 & ~0x1f);
                MEM[v7] = RETURNDATASIZE();
                RETURNDATACOPY(v7 + 32, 0, RETURNDATASIZE());
            }
            if (v5) {
                v4 = MEM[v6] >= 32;
            }
            require(v4);
            require(32 + v6 + MEM[v6] - (32 + v6) >= 32);
            if (MEM[32 + v6]) {
                require(v0 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                require((v0 << 5) + varg0.data + 32 - ((v0 << 5) + varg0.data) >= 32);
                require(varg0[v0 << 5][v0] == address(varg0[v0 << 5][v0]));
                MEM[MEM[64] + 68] = MEM[32 + v6];
                MEM[MEM[64] + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | uint224(address(msg.sender));
                v8 = v9 = 0;
                while (v8 < 68) {
                    MEM[v8 + MEM[64]] = MEM[v8 + (MEM[64] + 32)];
                    v8 += 32;
                }
                if (v8 <= 68) {
                    goto 0x33aa0x3398B0x20f30x15eaB0x445;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v10 = v11 = address(varg0[v0 << 5][v0]).call(MEM[(MEM[64]) len (68 + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v12 = 96;
                } else {
                    v12 = v13 = MEM[64];
                    MEM[64] = v13 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v13] = RETURNDATASIZE();
                    RETURNDATACOPY(v13 + 32, 0, RETURNDATASIZE());
                }
                if (v11) {
                    v10 = v14 = !MEM[v12];
                    if (MEM[v12]) {
                        require(32 + v12 + MEM[v12] - (32 + v12) >= 32);
                        v10 = MEM[32 + v12];
                        require(v10 == bool(v10));
                    }
                }
                require(v10, Error('BBVault: TRANSFER_FAILED'));
            }
        } else if (this.balance) {
            v15 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);
            require(bool(v15), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
        }
        v0 = 0x3977(v0);
    }
}

function 0x6e0e14e3() public nonPayable { 
    require(!_refund, Error('BBVault: SETTLE_LOCK'));
    require(2 <= _borrow[msg.sender], Error('BBVault: FORBIDDEN'));
    _refund = 'SETTLE';
}

function removeWhitelist(address varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 == varg0);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    _borrow[varg0] = 0;
}

function owner() public nonPayable { 
    return _owner;
}

function executeOperation(address[] varg0, uint256[] varg1, uint256[] varg2, address varg3, bytes varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 <= 0xffffffffffffffff);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= 0xffffffffffffffff);
    v0 = varg0.data;
    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);
    require(varg1 <= 0xffffffffffffffff);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= 0xffffffffffffffff);
    require(4 + varg1 + (varg1.length << 5) + 32 <= msg.data.length);
    require(varg2 <= 0xffffffffffffffff);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= 0xffffffffffffffff);
    require(4 + varg2 + (varg2.length << 5) + 32 <= msg.data.length);
    require(varg3 == address(varg3));
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < msg.data.length);
    require(varg4.length <= 0xffffffffffffffff);
    require(4 + varg4 + varg4.length + 32 <= msg.data.length);
    require(0 < varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v1 = v2 = varg1[0][32][0];
    require(0 < varg2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    CALLDATACOPY(v3.data, varg4.data, varg4.length);
    MEM[varg4.length + v3.data] = 0;
    require(_refund == keccak256(v3.data), Error('BBVault: STATUS'));
    require(varg4.data + varg4.length - varg4.data >= 32);
    require(msg.data[varg4.data] <= 0xffffffffffffffff);
    require(varg4.data + varg4.length - (varg4.data + msg.data[varg4.data]) >= 288);
    v4 = MEM[64];
    require(!((v4 + 288 < v4) | (v4 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v4 + 288;
    require(varg4[msg.data[varg4.data]] == address(varg4[msg.data[varg4.data]]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 32] == address(msg.data[varg4.data + msg.data[varg4.data] + 32]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 64] == address(msg.data[varg4.data + msg.data[varg4.data] + 64]));
    require(msg.data[varg4.data + msg.data[varg4.data] + 192] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 31 < varg4.data + varg4.length);
    v5 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v5 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v5 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v5 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]];
    v6 = v7 = MEM[64] + 32;
    v8 = v9 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]] << 5) + 32 <= varg4.data + varg4.length);
    v10 = v11 = 0;
    while (v10 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 192]]) {
        MEM[v6] = msg.data[v8];
        v6 += 32;
        v8 += 32;
        v10 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 224] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 31 < varg4.data + varg4.length);
    v12 = 0x3867(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v12 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v12 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v12 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]];
    v13 = v14 = MEM[64] + 32;
    v15 = v16 = varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + 32;
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224] + (msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]] << 5) + 32 <= varg4.data + varg4.length);
    v17 = v18 = 0;
    while (v17 < msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 224]]) {
        MEM[v13] = msg.data[v15];
        v13 += 32;
        v15 += 32;
        v17 += 1;
    }
    require(msg.data[varg4.data + msg.data[varg4.data] + 256] <= 0xffffffffffffffff);
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 31 < varg4.data + varg4.length);
    v19 = 0x388a(msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v19 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v19 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v19 + 31);
    MEM[MEM[64]] = msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]];
    require(varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]] + 32 <= varg4.data + varg4.length);
    CALLDATACOPY(MEM[64] + 32, varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256] + 32, msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg4.data + msg.data[varg4.data] + msg.data[varg4.data + msg.data[varg4.data] + 256]])] = 0;
    if (!v2) {
        require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v1 = MEM[32 + (msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64]];
    }
    v20 = _SafeAdd(v1, varg2[0][32][0]);
    require(msg.data[varg4.data + msg.data[varg4.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg4.data + msg.data[varg4.data] + 96] << 5) + MEM[64] + 32] = v20;
    while (v21 < MEM[MEM[64]]) {
        require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v22 = v23 = MEM[32 + (v21 << 5) + MEM[64]];
        if (0 != v23) {
            require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v24 = MEM[32 + (v21 << 5) + MEM[64]];
            if (uint8(bool(v24)) != 3) {
                v25 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v26) - MEM[64] + ~31);
                MEM[v25.data] = 32;
                MEM[v25.data + 32] = address(varg4[msg.data[varg4.data]]);
                MEM[v25.data + 64] = address(msg.data[varg4.data + msg.data[varg4.data] + 32]);
                MEM[v25.data + 96] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                MEM[v25.data + 128] = v21;
                MEM[v25.data + 160] = msg.data[varg4.data + msg.data[varg4.data] + 128];
                MEM[v25.data + 192] = msg.data[varg4.data + msg.data[varg4.data] + 160];
                MEM[v25.data + 224] = 288;
                MEM[v25.data + 320] = MEM[MEM[64]];
                v27 = v28 = v25.data + 320 + 32;
                v29 = v30 = MEM[64] + 32;
                v31 = v32 = 0;
                while (v31 < MEM[MEM[64]]) {
                    MEM[v27] = MEM[v29];
                    v27 += 32;
                    v29 += 32;
                    v31 += 1;
                }
                MEM[v25.data + 256] = v27 - v25.data + ~31;
                MEM[v27] = MEM[MEM[64]];
                v26 = v33 = v27 + 32;
                v34 = v35 = MEM[64] + 32;
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v26] = MEM[v34];
                    v26 += 32;
                    v34 += 32;
                    v36 += 1;
                }
                MEM[v25.data + 288] = ~31 + (v26 - v25.data);
                MEM[v26] = MEM[MEM[64]];
                v38 = v39 = 0;
                while (v38 < MEM[MEM[64]]) {
                    MEM[v38 + (v26 + 32)] = MEM[v38 + (MEM[64] + 32)];
                    v38 += 32;
                }
                if (v38 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x4b7;
                } else {
                    MEM[MEM[MEM[64]] + (v26 + 32)] = 0;
                }
                v40 = v25.length;
                v41 = v25.data;
                _refund = keccak256(v25);
                if (bool(v24) != 4) {
                    if (bool(v24) != 9) {
                        if (bool(v24) != 10) {
                            v42 = v43 = bool(v24) == 5;
                            if (bool(v24) != 5) {
                                v42 = v44 = bool(v24) == 7;
                            }
                            if (!v42) {
                                v42 = bool(v24) == 11;
                            }
                            if (!v42) {
                                if (bool(v24) != 12) {
                                    if (bool(v24) != 2) {
                                        if (bool(v24) != 6) {
                                            if (bool(v24) != 8) {
                                                require(bool(v24) == 1, Error('BBVault: TYPE'));
                                                v22 = 0;
                                                v45 = address(v24 >> 24);
                                                v46 = new array[](v25.length);
                                                v47 = v48 = 0;
                                                while (v47 < v25.length) {
                                                    MEM[v47 + v46.data] = MEM[v47 + v25.data];
                                                    v47 += 32;
                                                }
                                                if (v47 <= v25.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x4b7;
                                                } else {
                                                    MEM[v25.length + v46.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x4b7;
                                            } else {
                                                v49 = v50 = address(v24 >> 24);
                                                v51 = new array[](v23);
                                                v52 = new array[](160);
                                                v53 = new array[](v25.length);
                                                v54 = v55 = 0;
                                                while (v54 < v25.length) {
                                                    MEM[v54 + v53.data] = MEM[v54 + v25.data];
                                                    v54 += 32;
                                                }
                                                if (v54 <= v25.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x4b7;
                                                } else {
                                                    MEM[v25.length + v53.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x4b7;
                                            }
                                        } else {
                                            v56 = new array[](v25.length);
                                            v57 = v58 = 0;
                                            while (v57 < v25.length) {
                                                MEM[v57 + v56.data] = MEM[v57 + v25.data];
                                                v57 += 32;
                                            }
                                            if (v57 <= v25.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x4b7;
                                            } else {
                                                MEM[v25.length + v56.data] = 0;
                                            }
                                            require(bool((address(v24 >> 24)).code.size));
                                            v59, /* bool */ v60 = address(v24 >> 24).flashLoan(address(this), address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v23, v56).gas(msg.gas);
                                            require(bool(v59), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v60 == bool(v60));
                                            require(v60, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x4b7;
                                        }
                                    } else {
                                        v22 = v61 = 0;
                                        v45 = v62 = address(v24 >> 24);
                                        v63 = new array[](v25.length);
                                        v64 = v65 = 0;
                                        while (v64 < v25.length) {
                                            MEM[v64 + v63.data] = MEM[v64 + v25.data];
                                            v64 += 32;
                                        }
                                        if (v64 <= v25.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x4b7;
                                        } else {
                                            MEM[v25.length + v63.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x4b7;
                                    }
                                } else {
                                    if (v24 & 0x10) {
                                        v22 = v66 = v23 << 128;
                                    }
                                    v49 = address(v24 >> 24);
                                    v67 = new array[](v25.length);
                                    v68 = v69 = 0;
                                    while (v68 < v25.length) {
                                        MEM[v68 + v67.data] = MEM[v68 + v25.data];
                                        v68 += 32;
                                    }
                                    if (v68 <= v25.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x4b7;
                                    } else {
                                        MEM[v25.length + v67.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x4b7;
                                }
                            } else {
                                v49 = v70 = address(v24 >> 24);
                                v71 = new array[](128);
                                v72 = new array[](v25.length);
                                v73 = v74 = 0;
                                while (v73 < v25.length) {
                                    MEM[v73 + v72.data] = MEM[v73 + v25.data];
                                    v73 += 32;
                                }
                                if (v73 <= v25.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x4b7;
                                } else {
                                    MEM[v25.length + v72.data] = 0;
                                }
                            }
                            require(bool(v49.code.size));
                            v75 = v49.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v22, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), address(this), v71, v51, v67, v72, v52, v53).gas(msg.gas);
                            require(bool(v75), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x4b7;
                        } else {
                            v22 = v76 = 0;
                            v45 = v77 = address(v24 >> 24);
                            v78 = new array[](v25.length);
                            v79 = v80 = 0;
                            while (v79 < v25.length) {
                                MEM[v79 + v78.data] = MEM[v79 + v25.data];
                                v79 += 32;
                            }
                            if (v79 <= v25.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x4b7;
                            } else {
                                MEM[v25.length + v78.data] = 0;
                            }
                        }
                    } else {
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                        v83 = new uint256[](1);
                        CALLDATACOPY(v83.data, msg.data.length, 32);
                        require(0 < v83.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v84 = v83.data;
                        v83[0] = v23;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v45 = v85 = address(v24 >> 24);
                        v86 = new uint256[](v81.length);
                        v87 = v88 = v86.data;
                        v89 = v90 = v81.data;
                        v91 = v92 = 0;
                        while (v91 < v81.length) {
                            MEM[v87] = address(MEM[v89]);
                            v87 += 32;
                            v89 += 32;
                            v91 += 1;
                        }
                        MEM[v87] = v83.length;
                        v93 = v94 = v87 + 32;
                        v95 = v96 = v83.data;
                        v97 = v98 = 0;
                        while (v97 < v83.length) {
                            MEM[v93] = MEM[v95];
                            v93 += 32;
                            v95 += 32;
                            v97 += 1;
                        }
                        MEM[v93] = v25.length;
                        v99 = v100 = 0;
                        while (v99 < v25.length) {
                            MEM[v99 + (v93 + 32)] = MEM[v99 + v25.data];
                            v99 += 32;
                        }
                        if (v99 <= v25.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x4b7;
                        } else {
                            MEM[v25.length + (v93 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x4b7;
                    }
                    require(bool(v45.code.size));
                    v101 = v45.call(v86, v78, v63, v46, v22, v22, address(this), address(this), v86, v78, v63, v46, 1, v22, v87 - (4 + MEM[64]), address(this), address(this), v86, v78, v63, v46, v102, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v101), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = address(msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    v105 = new uint256[](1);
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = v105.data;
                    v105[0] = v23;
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = new uint256[](v103.length);
                    v109 = v110 = v108.data;
                    v111 = v112 = v103.data;
                    v113 = v114 = 0;
                    while (v113 < v103.length) {
                        MEM[v109] = address(MEM[v111]);
                        v109 += 32;
                        v111 += 32;
                        v113 += 1;
                    }
                    v109 = new uint256[](v105.length);
                    v115 = v116 = v109.data;
                    v117 = v118 = v105.data;
                    v119 = v120 = 0;
                    while (v119 < v105.length) {
                        MEM[v115] = MEM[v117];
                        v115 += 32;
                        v117 += 32;
                        v119 += 1;
                    }
                    v115 = new uint256[](v107.length);
                    v121 = v122 = v115.data;
                    v123 = v124 = v107.data;
                    v125 = v126 = 0;
                    while (v125 < v107.length) {
                        MEM[v121] = MEM[v123];
                        v121 += 32;
                        v123 += 32;
                        v125 += 1;
                    }
                    v121 = new array[](v25.length);
                    v127 = v128 = 0;
                    while (v127 < v25.length) {
                        MEM[v127 + v121.data] = MEM[v127 + v25.data];
                        v127 += 32;
                    }
                    if (v127 <= v25.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x4b7;
                    } else {
                        MEM[v25.length + v121.data] = 0;
                    }
                    require(bool((address(v24 >> 24)).code.size));
                    v129 = address(v24 >> 24).flashLoan(address(this), v108, v109, v115, address(this), v121, uint16(0), v102, address(msg.data[varg4.data + msg.data[varg4.data] + 64])).gas(msg.gas);
                    require(bool(v129), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x4b7;
                }
                goto 0x50090x4b7;
            } else {
                require(bool((address(v24 >> 24)).code.size));
                v130 = address(v24 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg4.data + msg.data[varg4.data] + 64]), v23, this).gas(msg.gas);
                require(bool(v130), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v21 += 1;
    }
    if (msg.data[varg4.data + msg.data[varg4.data] + 128]) {
        0x20f3(msg.data[varg4.data + msg.data[varg4.data] + 128], msg.data[varg4.data + msg.data[varg4.data] + 32], msg.data[varg4.data + msg.data[varg4.data] + 64]);
    }
    v131 = v132 = 0;
    while (v131 < MEM[MEM[64]]) {
        require(v131 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v133 = v133 + MEM[32 + (v131 << 5) + MEM[64]];
        v131 += 1;
    }
    _refund = 'EXECUTION';
    v134 = new array[](MEM[MEM[64]]);
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        MEM[v135 + v134.data] = MEM[v135 + (MEM[64] + 32)];
        v135 += 32;
    }
    if (v135 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x4b7;
    } else {
        MEM[MEM[MEM[64]] + v134.data] = 0;
    }
    require(bool((address(varg4[msg.data[varg4.data]])).code.size));
    v137 = address(varg4[msg.data[varg4.data]]).call(0x7fe3ba8b, address(msg.data[varg4.data + msg.data[varg4.data] + 32]), v133, v134).gas(msg.gas);
    require(bool(v137), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v138 = v139 = 0;
    while (v138 < MEM[MEM[64]]) {
        require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v140 = v141 = MEM[32 + (v138 << 5) + MEM[64]];
        if (0 != v141) {
            require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v142 = v143 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v138 << 5) + MEM[64] + 32]) != 4) {
                v142 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v142) {
                if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v144 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v144), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v140 = MEM[MEM[64]];
                }
                if (v140) {
                    0x20f3(v140, MEM[(v138 << 5) + MEM[64] + 32] >> 24, msg.data[varg4.data + msg.data[varg4.data] + 64]);
                    if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v145 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v145), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v141;
                // 0x95ea7b3: approve
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v138 << 5) + MEM[64] + 32] >> 24));
                v146 = v147 = 0;
                while (v146 < 68) {
                    MEM[v146 + MEM[64]] = MEM[v146 + (MEM[64] + 32)];
                    v146 += 32;
                }
                if (v146 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x4b7;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v148 = v149 = address(msg.data[varg4.data + msg.data[varg4.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v150 = v151 = 96;
                } else {
                    v150 = v152 = MEM[64];
                    MEM[64] = v152 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v152] = RETURNDATASIZE();
                    RETURNDATACOPY(v152 + 32, 0, RETURNDATASIZE());
                }
                if (v149) {
                    v148 = v153 = !MEM[v150];
                    if (MEM[v150]) {
                        require(32 + v150 + MEM[v150] - (32 + v150) >= 32);
                        v148 = MEM[32 + v150];
                        require(v148 == bool(v148));
                    }
                }
                require(v148, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v138 += 1;
    }
    return bool(1);
}

function 0xa60b0d3c(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { 
    require(msg.data.length - 4 >= 96);
    require(varg2 <= 0xffffffffffffffff);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= 0xffffffffffffffff);
    require(4 + varg2 + varg2.length + 32 <= msg.data.length);
    v0 = v1 = 0;
    if (varg0 <= v1) {
    }
    CALLDATACOPY(v2.data, varg2.data, varg2.length);
    MEM[varg2.length + v2.data] = 0;
    require(_refund == keccak256(v2.data), Error('BBVault: STATUS'));
    require(varg2.data + varg2.length - varg2.data >= 32);
    require(msg.data[varg2.data] <= 0xffffffffffffffff);
    require(varg2.data + varg2.length - (varg2.data + msg.data[varg2.data]) >= 288);
    v3 = MEM[64];
    require(!((v3 + 288 < v3) | (v3 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v3 + 288;
    require(varg2[msg.data[varg2.data]] == address(varg2[msg.data[varg2.data]]));
    require(msg.data[varg2.data + msg.data[varg2.data] + 32] == address(msg.data[varg2.data + msg.data[varg2.data] + 32]));
    require(msg.data[varg2.data + msg.data[varg2.data] + 64] == address(msg.data[varg2.data + msg.data[varg2.data] + 64]));
    require(msg.data[varg2.data + msg.data[varg2.data] + 192] <= 0xffffffffffffffff);
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192] + 31 < varg2.data + varg2.length);
    v4 = 0x3867(msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v4 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v4 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v4 + 31);
    MEM[MEM[64]] = msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192]];
    v5 = v6 = MEM[64] + 32;
    v7 = v8 = varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192] + 32;
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192] + (msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192]] << 5) + 32 <= varg2.data + varg2.length);
    v9 = v10 = 0;
    while (v9 < msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 192]]) {
        MEM[v5] = msg.data[v7];
        v5 += 32;
        v7 += 32;
        v9 += 1;
    }
    require(msg.data[varg2.data + msg.data[varg2.data] + 224] <= 0xffffffffffffffff);
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224] + 31 < varg2.data + varg2.length);
    v11 = 0x3867(msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v11 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v11 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v11 + 31);
    MEM[MEM[64]] = msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224]];
    v12 = v13 = MEM[64] + 32;
    v14 = v15 = varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224] + 32;
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224] + (msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224]] << 5) + 32 <= varg2.data + varg2.length);
    v16 = v17 = 0;
    while (v16 < msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 224]]) {
        MEM[v12] = msg.data[v14];
        v12 += 32;
        v14 += 32;
        v16 += 1;
    }
    require(msg.data[varg2.data + msg.data[varg2.data] + 256] <= 0xffffffffffffffff);
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256] + 31 < varg2.data + varg2.length);
    v18 = 0x388a(msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v18 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v18 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v18 + 31);
    MEM[MEM[64]] = msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256]];
    require(varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256] + msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256]] + 32 <= varg2.data + varg2.length);
    CALLDATACOPY(MEM[64] + 32, varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256] + 32, msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg2.data + msg.data[varg2.data] + msg.data[varg2.data + msg.data[varg2.data] + 256]])] = 0;
    if (!v1) {
        require(msg.data[varg2.data + msg.data[varg2.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v0 = MEM[32 + (msg.data[varg2.data + msg.data[varg2.data] + 96] << 5) + MEM[64]];
    }
    v19 = _SafeAdd(v0, v20);
    require(msg.data[varg2.data + msg.data[varg2.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg2.data + msg.data[varg2.data] + 96] << 5) + MEM[64] + 32] = v19;
    while (v21 < MEM[MEM[64]]) {
        require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v22 = v23 = MEM[32 + (v21 << 5) + MEM[64]];
        if (0 != v23) {
            require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v24 = MEM[32 + (v21 << 5) + MEM[64]];
            if (uint8(bool(v24)) != 3) {
                v25 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v26) - MEM[64] + ~31);
                MEM[v25.data] = 32;
                MEM[v25.data + 32] = address(varg2[msg.data[varg2.data]]);
                MEM[v25.data + 64] = address(msg.data[varg2.data + msg.data[varg2.data] + 32]);
                MEM[v25.data + 96] = address(msg.data[varg2.data + msg.data[varg2.data] + 64]);
                MEM[v25.data + 128] = v21;
                MEM[v25.data + 160] = msg.data[varg2.data + msg.data[varg2.data] + 128];
                MEM[v25.data + 192] = msg.data[varg2.data + msg.data[varg2.data] + 160];
                MEM[v25.data + 224] = 288;
                MEM[v25.data + 320] = MEM[MEM[64]];
                v27 = v28 = v25.data + 320 + 32;
                v29 = v30 = MEM[64] + 32;
                v31 = v32 = 0;
                while (v31 < MEM[MEM[64]]) {
                    MEM[v27] = MEM[v29];
                    v27 += 32;
                    v29 += 32;
                    v31 += 1;
                }
                MEM[v25.data + 256] = v27 - v25.data + ~31;
                MEM[v27] = MEM[MEM[64]];
                v26 = v33 = v27 + 32;
                v34 = v35 = MEM[64] + 32;
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v26] = MEM[v34];
                    v26 += 32;
                    v34 += 32;
                    v36 += 1;
                }
                MEM[v25.data + 288] = ~31 + (v26 - v25.data);
                MEM[v26] = MEM[MEM[64]];
                v38 = v39 = 0;
                while (v38 < MEM[MEM[64]]) {
                    MEM[v38 + (v26 + 32)] = MEM[v38 + (MEM[64] + 32)];
                    v38 += 32;
                }
                if (v38 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x1844B0x502;
                } else {
                    MEM[MEM[MEM[64]] + (v26 + 32)] = 0;
                }
                v40 = v25.length;
                v41 = v25.data;
                _refund = keccak256(v25);
                if (bool(v24) != 4) {
                    if (bool(v24) != 9) {
                        if (bool(v24) != 10) {
                            v42 = v43 = bool(v24) == 5;
                            if (bool(v24) != 5) {
                                v42 = v44 = bool(v24) == 7;
                            }
                            if (!v42) {
                                v42 = bool(v24) == 11;
                            }
                            if (!v42) {
                                if (bool(v24) != 12) {
                                    if (bool(v24) != 2) {
                                        if (bool(v24) != 6) {
                                            if (bool(v24) != 8) {
                                                require(bool(v24) == 1, Error('BBVault: TYPE'));
                                                v22 = 0;
                                                v45 = address(v24 >> 24);
                                                v46 = new array[](v25.length);
                                                v47 = v48 = 0;
                                                while (v47 < v25.length) {
                                                    MEM[v47 + v46.data] = MEM[v47 + v25.data];
                                                    v47 += 32;
                                                }
                                                if (v47 <= v25.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x1844B0x502;
                                                } else {
                                                    MEM[v25.length + v46.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x1844B0x502;
                                            } else {
                                                v49 = v50 = address(v24 >> 24);
                                                v51 = new array[](v23);
                                                v52 = new array[](160);
                                                v53 = new array[](v25.length);
                                                v54 = v55 = 0;
                                                while (v54 < v25.length) {
                                                    MEM[v54 + v53.data] = MEM[v54 + v25.data];
                                                    v54 += 32;
                                                }
                                                if (v54 <= v25.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x1844B0x502;
                                                } else {
                                                    MEM[v25.length + v53.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x1844B0x502;
                                            }
                                        } else {
                                            v56 = new array[](v25.length);
                                            v57 = v58 = 0;
                                            while (v57 < v25.length) {
                                                MEM[v57 + v56.data] = MEM[v57 + v25.data];
                                                v57 += 32;
                                            }
                                            if (v57 <= v25.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x1844B0x502;
                                            } else {
                                                MEM[v25.length + v56.data] = 0;
                                            }
                                            require(bool((address(v24 >> 24)).code.size));
                                            v59, /* bool */ v60 = address(v24 >> 24).flashLoan(address(this), address(msg.data[varg2.data + msg.data[varg2.data] + 64]), v23, v56).gas(msg.gas);
                                            require(bool(v59), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v60 == bool(v60));
                                            require(v60, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x1844B0x502;
                                        }
                                    } else {
                                        v22 = v61 = 0;
                                        v45 = v62 = address(v24 >> 24);
                                        v63 = new array[](v25.length);
                                        v64 = v65 = 0;
                                        while (v64 < v25.length) {
                                            MEM[v64 + v63.data] = MEM[v64 + v25.data];
                                            v64 += 32;
                                        }
                                        if (v64 <= v25.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x1844B0x502;
                                        } else {
                                            MEM[v25.length + v63.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x1844B0x502;
                                    }
                                } else {
                                    if (v24 & 0x10) {
                                        v22 = v66 = v23 << 128;
                                    }
                                    v49 = address(v24 >> 24);
                                    v67 = new array[](v25.length);
                                    v68 = v69 = 0;
                                    while (v68 < v25.length) {
                                        MEM[v68 + v67.data] = MEM[v68 + v25.data];
                                        v68 += 32;
                                    }
                                    if (v68 <= v25.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x1844B0x502;
                                    } else {
                                        MEM[v25.length + v67.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x1844B0x502;
                                }
                            } else {
                                v49 = v70 = address(v24 >> 24);
                                v71 = new array[](128);
                                v72 = new array[](v25.length);
                                v73 = v74 = 0;
                                while (v73 < v25.length) {
                                    MEM[v73 + v72.data] = MEM[v73 + v25.data];
                                    v73 += 32;
                                }
                                if (v73 <= v25.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x1844B0x502;
                                } else {
                                    MEM[v25.length + v72.data] = 0;
                                }
                            }
                            require(bool(v49.code.size));
                            v75 = v49.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v22, address(msg.data[varg2.data + msg.data[varg2.data] + 64]), address(this), v71, v51, v67, v72, v52, v53).gas(msg.gas);
                            require(bool(v75), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x1844B0x502;
                        } else {
                            v22 = v76 = 0;
                            v45 = v77 = address(v24 >> 24);
                            v78 = new array[](v25.length);
                            v79 = v80 = 0;
                            while (v79 < v25.length) {
                                MEM[v79 + v78.data] = MEM[v79 + v25.data];
                                v79 += 32;
                            }
                            if (v79 <= v25.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x1844B0x502;
                            } else {
                                MEM[v25.length + v78.data] = 0;
                            }
                        }
                    } else {
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = address(msg.data[varg2.data + msg.data[varg2.data] + 64]);
                        v83 = new uint256[](1);
                        CALLDATACOPY(v83.data, msg.data.length, 32);
                        require(0 < v83.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v84 = v83.data;
                        v83[0] = v23;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v45 = v85 = address(v24 >> 24);
                        v86 = new uint256[](v81.length);
                        v87 = v88 = v86.data;
                        v89 = v90 = v81.data;
                        v91 = v92 = 0;
                        while (v91 < v81.length) {
                            MEM[v87] = address(MEM[v89]);
                            v87 += 32;
                            v89 += 32;
                            v91 += 1;
                        }
                        MEM[v87] = v83.length;
                        v93 = v94 = v87 + 32;
                        v95 = v96 = v83.data;
                        v97 = v98 = 0;
                        while (v97 < v83.length) {
                            MEM[v93] = MEM[v95];
                            v93 += 32;
                            v95 += 32;
                            v97 += 1;
                        }
                        MEM[v93] = v25.length;
                        v99 = v100 = 0;
                        while (v99 < v25.length) {
                            MEM[v99 + (v93 + 32)] = MEM[v99 + v25.data];
                            v99 += 32;
                        }
                        if (v99 <= v25.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x1844B0x502;
                        } else {
                            MEM[v25.length + (v93 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x1844B0x502;
                    }
                    require(bool(v45.code.size));
                    v101 = v45.call(v86, v78, v63, v46, v22, v22, address(this), address(this), v86, v78, v63, v46, 1, v22, v87 - (4 + MEM[64]), address(this), address(this), v86, v78, v63, v46, v102, address(msg.data[varg2.data + msg.data[varg2.data] + 64])).gas(msg.gas);
                    require(bool(v101), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = address(msg.data[varg2.data + msg.data[varg2.data] + 64]);
                    v105 = new uint256[](1);
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = v105.data;
                    v105[0] = v23;
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = new uint256[](v103.length);
                    v109 = v110 = v108.data;
                    v111 = v112 = v103.data;
                    v113 = v114 = 0;
                    while (v113 < v103.length) {
                        MEM[v109] = address(MEM[v111]);
                        v109 += 32;
                        v111 += 32;
                        v113 += 1;
                    }
                    v109 = new uint256[](v105.length);
                    v115 = v116 = v109.data;
                    v117 = v118 = v105.data;
                    v119 = v120 = 0;
                    while (v119 < v105.length) {
                        MEM[v115] = MEM[v117];
                        v115 += 32;
                        v117 += 32;
                        v119 += 1;
                    }
                    v115 = new uint256[](v107.length);
                    v121 = v122 = v115.data;
                    v123 = v124 = v107.data;
                    v125 = v126 = 0;
                    while (v125 < v107.length) {
                        MEM[v121] = MEM[v123];
                        v121 += 32;
                        v123 += 32;
                        v125 += 1;
                    }
                    v121 = new array[](v25.length);
                    v127 = v128 = 0;
                    while (v127 < v25.length) {
                        MEM[v127 + v121.data] = MEM[v127 + v25.data];
                        v127 += 32;
                    }
                    if (v127 <= v25.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x1844B0x502;
                    } else {
                        MEM[v25.length + v121.data] = 0;
                    }
                    require(bool((address(v24 >> 24)).code.size));
                    v129 = address(v24 >> 24).flashLoan(address(this), v108, v109, v115, address(this), v121, uint16(0), v102, address(msg.data[varg2.data + msg.data[varg2.data] + 64])).gas(msg.gas);
                    require(bool(v129), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x1844B0x502;
                }
                goto 0x50090x1844B0x502;
            } else {
                require(bool((address(v24 >> 24)).code.size));
                v130 = address(v24 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg2.data + msg.data[varg2.data] + 64]), v23, this).gas(msg.gas);
                require(bool(v130), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v21 += 1;
    }
    if (msg.data[varg2.data + msg.data[varg2.data] + 128]) {
        0x20f3(msg.data[varg2.data + msg.data[varg2.data] + 128], msg.data[varg2.data + msg.data[varg2.data] + 32], msg.data[varg2.data + msg.data[varg2.data] + 64]);
    }
    v131 = v132 = 0;
    while (v131 < MEM[MEM[64]]) {
        require(v131 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v133 = v133 + MEM[32 + (v131 << 5) + MEM[64]];
        v131 += 1;
    }
    _refund = 'EXECUTION';
    v134 = new array[](MEM[MEM[64]]);
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        MEM[v135 + v134.data] = MEM[v135 + (MEM[64] + 32)];
        v135 += 32;
    }
    if (v135 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x1844B0x502;
    } else {
        MEM[MEM[MEM[64]] + v134.data] = 0;
    }
    require(bool((address(varg2[msg.data[varg2.data]])).code.size));
    v137 = address(varg2[msg.data[varg2.data]]).call(0x7fe3ba8b, address(msg.data[varg2.data + msg.data[varg2.data] + 32]), v133, v134).gas(msg.gas);
    require(bool(v137), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v138 = v139 = 0;
    while (v138 < MEM[MEM[64]]) {
        require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v140 = v141 = MEM[32 + (v138 << 5) + MEM[64]];
        if (0 != v141) {
            require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v142 = v143 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v138 << 5) + MEM[64] + 32]) != 4) {
                v142 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v142) {
                if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v144 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v144), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v140 = MEM[MEM[64]];
                }
                if (v140) {
                    0x20f3(v140, MEM[(v138 << 5) + MEM[64] + 32] >> 24, msg.data[varg2.data + msg.data[varg2.data] + 64]);
                    if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v145 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v145), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v141;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v138 << 5) + MEM[64] + 32] >> 24));
                v146 = v147 = 0;
                while (v146 < 68) {
                    MEM[v146 + MEM[64]] = MEM[v146 + (MEM[64] + 32)];
                    v146 += 32;
                }
                if (v146 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x1844B0x502;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v148 = v149 = address(msg.data[varg2.data + msg.data[varg2.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v150 = v151 = 96;
                } else {
                    v150 = v152 = MEM[64];
                    MEM[64] = v152 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v152] = RETURNDATASIZE();
                    RETURNDATACOPY(v152 + 32, 0, RETURNDATASIZE());
                }
                if (v149) {
                    v148 = v153 = !MEM[v150];
                    if (MEM[v150]) {
                        require(32 + v150 + MEM[v150] - (32 + v150) >= 32);
                        v148 = MEM[32 + v150];
                        require(v148 == bool(v148));
                    }
                }
                require(v148, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v138 += 1;
    }
}

function changeOwner(address varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 == varg0);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    _owner = varg0;
}

function 0xad8add11() public nonPayable { 
    return bool(_refund);
}

function addWhitelist(address varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    _borrow[varg0] = varg1;
}

function () public payable { 
}

function 0xee33b7e2(address varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(varg1 <= 0xffffffffffffffff);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= 0xffffffffffffffff);
    require(4 + varg1 + varg1.length + 32 <= msg.data.length);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    MEM[varg1.length + MEM[64]] = 0;
    v0, v1 = varg0.delegatecall(MEM[(MEM[64]) len (varg1.length + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);
    if (RETURNDATASIZE() == 0) {
        goto 0x498e;
    } else {
        v2 = new bytes[](RETURNDATASIZE());
        RETURNDATACOPY(v2.data, 0, RETURNDATASIZE());
    }
}

function executeOperation(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public nonPayable { 
    require(msg.data.length - 4 >= 128);
    require(varg0 == varg0);
    require(varg3 <= 0xffffffffffffffff);
    require(4 + varg3 + 31 < msg.data.length);
    require(varg3.length <= 0xffffffffffffffff);
    require(4 + varg3 + varg3.length + 32 <= msg.data.length);
    0x1970(varg3.length, varg3.data, varg2, varg1, varg0);
}

function receiveFlashLoan(address[] varg0, uint256[] varg1, uint256[] varg2, bytes varg3) public nonPayable { 
    require(msg.data.length - 4 >= 128);
    require(varg0 <= 0xffffffffffffffff);
    require(4 + varg0 + 31 < msg.data.length);
    require(varg0.length <= 0xffffffffffffffff);
    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);
    require(varg1 <= 0xffffffffffffffff);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= 0xffffffffffffffff);
    require(4 + varg1 + (varg1.length << 5) + 32 <= msg.data.length);
    require(varg2 <= 0xffffffffffffffff);
    require(4 + varg2 + 31 < msg.data.length);
    require(varg2.length <= 0xffffffffffffffff);
    require(4 + varg2 + (varg2.length << 5) + 32 <= msg.data.length);
    require(varg3 <= 0xffffffffffffffff);
    require(4 + varg3 + 31 < msg.data.length);
    require(varg3.length <= 0xffffffffffffffff);
    require(4 + varg3 + varg3.length + 32 <= msg.data.length);
    require(0 < varg1.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v0 = v1 = varg1[0][32][0];
    require(0 < varg2.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    CALLDATACOPY(v2.data, varg3.data, varg3.length);
    MEM[varg3.length + v2.data] = 0;
    require(_refund == keccak256(v2.data), Error('BBVault: STATUS'));
    require(varg3.data + varg3.length - varg3.data >= 32);
    require(msg.data[varg3.data] <= 0xffffffffffffffff);
    require(varg3.data + varg3.length - (varg3.data + msg.data[varg3.data]) >= 288);
    v3 = MEM[64];
    require(!((v3 + 288 < v3) | (v3 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v3 + 288;
    require(varg3[msg.data[varg3.data]] == address(varg3[msg.data[varg3.data]]));
    require(msg.data[varg3.data + msg.data[varg3.data] + 32] == address(msg.data[varg3.data + msg.data[varg3.data] + 32]));
    require(msg.data[varg3.data + msg.data[varg3.data] + 64] == address(msg.data[varg3.data + msg.data[varg3.data] + 64]));
    require(msg.data[varg3.data + msg.data[varg3.data] + 192] <= 0xffffffffffffffff);
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192] + 31 < varg3.data + varg3.length);
    v4 = 0x3867(msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192]]);
    require(!((MEM[64] + (~0x1f & v4 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v4 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v4 + 31);
    MEM[MEM[64]] = msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192]];
    v5 = v6 = MEM[64] + 32;
    v7 = v8 = varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192] + 32;
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192] + (msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192]] << 5) + 32 <= varg3.data + varg3.length);
    v9 = v10 = 0;
    while (v9 < msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 192]]) {
        MEM[v5] = msg.data[v7];
        v5 += 32;
        v7 += 32;
        v9 += 1;
    }
    require(msg.data[varg3.data + msg.data[varg3.data] + 224] <= 0xffffffffffffffff);
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224] + 31 < varg3.data + varg3.length);
    v11 = 0x3867(msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224]]);
    require(!((MEM[64] + (~0x1f & v11 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v11 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v11 + 31);
    MEM[MEM[64]] = msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224]];
    v12 = v13 = MEM[64] + 32;
    v14 = v15 = varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224] + 32;
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224] + (msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224]] << 5) + 32 <= varg3.data + varg3.length);
    v16 = v17 = 0;
    while (v16 < msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 224]]) {
        MEM[v12] = msg.data[v14];
        v12 += 32;
        v14 += 32;
        v16 += 1;
    }
    require(msg.data[varg3.data + msg.data[varg3.data] + 256] <= 0xffffffffffffffff);
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256] + 31 < varg3.data + varg3.length);
    v18 = 0x388a(msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256]]);
    require(!((MEM[64] + (~0x1f & v18 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v18 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v18 + 31);
    MEM[MEM[64]] = msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256]];
    require(varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256] + msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256]] + 32 <= varg3.data + varg3.length);
    CALLDATACOPY(MEM[64] + 32, varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256] + 32, msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256]]);
    MEM[32 + (MEM[64] + msg.data[varg3.data + msg.data[varg3.data] + msg.data[varg3.data + msg.data[varg3.data] + 256]])] = 0;
    if (!v1) {
        require(msg.data[varg3.data + msg.data[varg3.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v0 = MEM[32 + (msg.data[varg3.data + msg.data[varg3.data] + 96] << 5) + MEM[64]];
    }
    v19 = _SafeAdd(v0, varg2[0][32][0]);
    require(msg.data[varg3.data + msg.data[varg3.data] + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[varg3.data + msg.data[varg3.data] + 96] << 5) + MEM[64] + 32] = v19;
    while (v20 < MEM[MEM[64]]) {
        require(v20 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v21 = v22 = MEM[32 + (v20 << 5) + MEM[64]];
        if (0 != v22) {
            require(v20 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v23 = MEM[32 + (v20 << 5) + MEM[64]];
            if (uint8(bool(v23)) != 3) {
                v24 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v25) - MEM[64] + ~31);
                MEM[v24.data] = 32;
                MEM[v24.data + 32] = address(varg3[msg.data[varg3.data]]);
                MEM[v24.data + 64] = address(msg.data[varg3.data + msg.data[varg3.data] + 32]);
                MEM[v24.data + 96] = address(msg.data[varg3.data + msg.data[varg3.data] + 64]);
                MEM[v24.data + 128] = v20;
                MEM[v24.data + 160] = msg.data[varg3.data + msg.data[varg3.data] + 128];
                MEM[v24.data + 192] = msg.data[varg3.data + msg.data[varg3.data] + 160];
                MEM[v24.data + 224] = 288;
                MEM[v24.data + 320] = MEM[MEM[64]];
                v26 = v27 = v24.data + 320 + 32;
                v28 = v29 = MEM[64] + 32;
                v30 = v31 = 0;
                while (v30 < MEM[MEM[64]]) {
                    MEM[v26] = MEM[v28];
                    v26 += 32;
                    v28 += 32;
                    v30 += 1;
                }
                MEM[v24.data + 256] = v26 - v24.data + ~31;
                MEM[v26] = MEM[MEM[64]];
                v25 = v32 = v26 + 32;
                v33 = v34 = MEM[64] + 32;
                v35 = v36 = 0;
                while (v35 < MEM[MEM[64]]) {
                    MEM[v25] = MEM[v33];
                    v25 += 32;
                    v33 += 32;
                    v35 += 1;
                }
                MEM[v24.data + 288] = ~31 + (v25 - v24.data);
                MEM[v25] = MEM[MEM[64]];
                v37 = v38 = 0;
                while (v37 < MEM[MEM[64]]) {
                    MEM[v37 + (v25 + 32)] = MEM[v37 + (MEM[64] + 32)];
                    v37 += 32;
                }
                if (v37 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x1983B0x5b9;
                } else {
                    MEM[MEM[MEM[64]] + (v25 + 32)] = 0;
                }
                v39 = v24.length;
                v40 = v24.data;
                _refund = keccak256(v24);
                if (bool(v23) != 4) {
                    if (bool(v23) != 9) {
                        if (bool(v23) != 10) {
                            v41 = v42 = bool(v23) == 5;
                            if (bool(v23) != 5) {
                                v41 = v43 = bool(v23) == 7;
                            }
                            if (!v41) {
                                v41 = bool(v23) == 11;
                            }
                            if (!v41) {
                                if (bool(v23) != 12) {
                                    if (bool(v23) != 2) {
                                        if (bool(v23) != 6) {
                                            if (bool(v23) != 8) {
                                                require(bool(v23) == 1, Error('BBVault: TYPE'));
                                                v21 = 0;
                                                v44 = address(v23 >> 24);
                                                v45 = new array[](v24.length);
                                                v46 = v47 = 0;
                                                while (v46 < v24.length) {
                                                    MEM[v46 + v45.data] = MEM[v46 + v24.data];
                                                    v46 += 32;
                                                }
                                                if (v46 <= v24.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x1983B0x5b9;
                                                } else {
                                                    MEM[v24.length + v45.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x1983B0x5b9;
                                            } else {
                                                v48 = v49 = address(v23 >> 24);
                                                v50 = new array[](v22);
                                                v51 = new array[](160);
                                                v52 = new array[](v24.length);
                                                v53 = v54 = 0;
                                                while (v53 < v24.length) {
                                                    MEM[v53 + v52.data] = MEM[v53 + v24.data];
                                                    v53 += 32;
                                                }
                                                if (v53 <= v24.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x1983B0x5b9;
                                                } else {
                                                    MEM[v24.length + v52.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x1983B0x5b9;
                                            }
                                        } else {
                                            v55 = new array[](v24.length);
                                            v56 = v57 = 0;
                                            while (v56 < v24.length) {
                                                MEM[v56 + v55.data] = MEM[v56 + v24.data];
                                                v56 += 32;
                                            }
                                            if (v56 <= v24.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x1983B0x5b9;
                                            } else {
                                                MEM[v24.length + v55.data] = 0;
                                            }
                                            require(bool((address(v23 >> 24)).code.size));
                                            v58, /* bool */ v59 = address(v23 >> 24).flashLoan(address(this), address(msg.data[varg3.data + msg.data[varg3.data] + 64]), v22, v55).gas(msg.gas);
                                            require(bool(v58), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v59 == bool(v59));
                                            require(v59, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x1983B0x5b9;
                                        }
                                    } else {
                                        v21 = v60 = 0;
                                        v44 = v61 = address(v23 >> 24);
                                        v62 = new array[](v24.length);
                                        v63 = v64 = 0;
                                        while (v63 < v24.length) {
                                            MEM[v63 + v62.data] = MEM[v63 + v24.data];
                                            v63 += 32;
                                        }
                                        if (v63 <= v24.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x1983B0x5b9;
                                        } else {
                                            MEM[v24.length + v62.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x1983B0x5b9;
                                    }
                                } else {
                                    if (v23 & 0x10) {
                                        v21 = v65 = v22 << 128;
                                    }
                                    v48 = address(v23 >> 24);
                                    v66 = new array[](v24.length);
                                    v67 = v68 = 0;
                                    while (v67 < v24.length) {
                                        MEM[v67 + v66.data] = MEM[v67 + v24.data];
                                        v67 += 32;
                                    }
                                    if (v67 <= v24.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x1983B0x5b9;
                                    } else {
                                        MEM[v24.length + v66.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x1983B0x5b9;
                                }
                            } else {
                                v48 = v69 = address(v23 >> 24);
                                v70 = new array[](128);
                                v71 = new array[](v24.length);
                                v72 = v73 = 0;
                                while (v72 < v24.length) {
                                    MEM[v72 + v71.data] = MEM[v72 + v24.data];
                                    v72 += 32;
                                }
                                if (v72 <= v24.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x1983B0x5b9;
                                } else {
                                    MEM[v24.length + v71.data] = 0;
                                }
                            }
                            require(bool(v48.code.size));
                            v74 = v48.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v21, address(msg.data[varg3.data + msg.data[varg3.data] + 64]), address(this), v70, v50, v66, v71, v51, v52).gas(msg.gas);
                            require(bool(v74), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x1983B0x5b9;
                        } else {
                            v21 = v75 = 0;
                            v44 = v76 = address(v23 >> 24);
                            v77 = new array[](v24.length);
                            v78 = v79 = 0;
                            while (v78 < v24.length) {
                                MEM[v78 + v77.data] = MEM[v78 + v24.data];
                                v78 += 32;
                            }
                            if (v78 <= v24.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x1983B0x5b9;
                            } else {
                                MEM[v24.length + v77.data] = 0;
                            }
                        }
                    } else {
                        v80 = new uint256[](1);
                        CALLDATACOPY(v80.data, msg.data.length, 32);
                        require(0 < v80.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v81 = v80.data;
                        v80[0] = address(msg.data[varg3.data + msg.data[varg3.data] + 64]);
                        v82 = new uint256[](1);
                        CALLDATACOPY(v82.data, msg.data.length, 32);
                        require(0 < v82.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v83 = v82.data;
                        v82[0] = v22;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v44 = v84 = address(v23 >> 24);
                        v85 = new uint256[](v80.length);
                        v86 = v87 = v85.data;
                        v88 = v89 = v80.data;
                        v90 = v91 = 0;
                        while (v90 < v80.length) {
                            MEM[v86] = address(MEM[v88]);
                            v86 += 32;
                            v88 += 32;
                            v90 += 1;
                        }
                        MEM[v86] = v82.length;
                        v92 = v93 = v86 + 32;
                        v94 = v95 = v82.data;
                        v96 = v97 = 0;
                        while (v96 < v82.length) {
                            MEM[v92] = MEM[v94];
                            v92 += 32;
                            v94 += 32;
                            v96 += 1;
                        }
                        MEM[v92] = v24.length;
                        v98 = v99 = 0;
                        while (v98 < v24.length) {
                            MEM[v98 + (v92 + 32)] = MEM[v98 + v24.data];
                            v98 += 32;
                        }
                        if (v98 <= v24.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x1983B0x5b9;
                        } else {
                            MEM[v24.length + (v92 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x1983B0x5b9;
                    }
                    require(bool(v44.code.size));
                    v100 = v44.call(v85, v77, v62, v45, v21, v21, address(this), address(this), v85, v77, v62, v45, 1, v21, v86 - (4 + MEM[64]), address(this), address(this), v85, v77, v62, v45, v101, address(msg.data[varg3.data + msg.data[varg3.data] + 64])).gas(msg.gas);
                    require(bool(v100), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v102 = new uint256[](1);
                    CALLDATACOPY(v102.data, msg.data.length, 32);
                    require(0 < v102.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v103 = v102.data;
                    v102[0] = address(msg.data[varg3.data + msg.data[varg3.data] + 64]);
                    v104 = new uint256[](1);
                    CALLDATACOPY(v104.data, msg.data.length, 32);
                    require(0 < v104.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v105 = v104.data;
                    v104[0] = v22;
                    CALLDATACOPY(v106.data, msg.data.length, 32);
                    require(0 < v106.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v107 = new uint256[](v102.length);
                    v108 = v109 = v107.data;
                    v110 = v111 = v102.data;
                    v112 = v113 = 0;
                    while (v112 < v102.length) {
                        MEM[v108] = address(MEM[v110]);
                        v108 += 32;
                        v110 += 32;
                        v112 += 1;
                    }
                    v108 = new uint256[](v104.length);
                    v114 = v115 = v108.data;
                    v116 = v117 = v104.data;
                    v118 = v119 = 0;
                    while (v118 < v104.length) {
                        MEM[v114] = MEM[v116];
                        v114 += 32;
                        v116 += 32;
                        v118 += 1;
                    }
                    v114 = new uint256[](v106.length);
                    v120 = v121 = v114.data;
                    v122 = v123 = v106.data;
                    v124 = v125 = 0;
                    while (v124 < v106.length) {
                        MEM[v120] = MEM[v122];
                        v120 += 32;
                        v122 += 32;
                        v124 += 1;
                    }
                    v120 = new array[](v24.length);
                    v126 = v127 = 0;
                    while (v126 < v24.length) {
                        MEM[v126 + v120.data] = MEM[v126 + v24.data];
                        v126 += 32;
                    }
                    if (v126 <= v24.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x1983B0x5b9;
                    } else {
                        MEM[v24.length + v120.data] = 0;
                    }
                    require(bool((address(v23 >> 24)).code.size));
                    v128 = address(v23 >> 24).flashLoan(address(this), v107, v108, v114, address(this), v120, uint16(0), v101, address(msg.data[varg3.data + msg.data[varg3.data] + 64])).gas(msg.gas);
                    require(bool(v128), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x1983B0x5b9;
                }
                goto 0x50090x1983B0x5b9;
            } else {
                require(bool((address(v23 >> 24)).code.size));
                v129 = address(v23 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[varg3.data + msg.data[varg3.data] + 64]), v22, this).gas(msg.gas);
                require(bool(v129), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v20 += 1;
    }
    if (msg.data[varg3.data + msg.data[varg3.data] + 128]) {
        0x20f3(msg.data[varg3.data + msg.data[varg3.data] + 128], msg.data[varg3.data + msg.data[varg3.data] + 32], msg.data[varg3.data + msg.data[varg3.data] + 64]);
    }
    v130 = v131 = 0;
    while (v130 < MEM[MEM[64]]) {
        require(v130 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v132 = v132 + MEM[32 + (v130 << 5) + MEM[64]];
        v130 += 1;
    }
    _refund = 'EXECUTION';
    v133 = new array[](MEM[MEM[64]]);
    v134 = v135 = 0;
    while (v134 < MEM[MEM[64]]) {
        MEM[v134 + v133.data] = MEM[v134 + (MEM[64] + 32)];
        v134 += 32;
    }
    if (v134 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x1983B0x5b9;
    } else {
        MEM[MEM[MEM[64]] + v133.data] = 0;
    }
    require(bool((address(varg3[msg.data[varg3.data]])).code.size));
    v136 = address(varg3[msg.data[varg3.data]]).call(0x7fe3ba8b, address(msg.data[varg3.data + msg.data[varg3.data] + 32]), v132, v133).gas(msg.gas);
    require(bool(v136), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v137 = v138 = 0;
    while (v137 < MEM[MEM[64]]) {
        require(v137 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v139 = v140 = MEM[32 + (v137 << 5) + MEM[64]];
        if (0 != v140) {
            require(v137 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v141 = v142 = bool(MEM[(v137 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v137 << 5) + MEM[64] + 32]) != 4) {
                v141 = bool(MEM[(v137 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v141) {
                if (bool(MEM[(v137 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v137 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v143 = address(MEM[(v137 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v143), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v139 = MEM[MEM[64]];
                }
                if (v139) {
                    0x20f3(v139, MEM[(v137 << 5) + MEM[64] + 32] >> 24, msg.data[varg3.data + msg.data[varg3.data] + 64]);
                    if (bool(MEM[(v137 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v137 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v144 = address(MEM[(v137 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v144), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v140;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v137 << 5) + MEM[64] + 32] >> 24));
                v145 = v146 = 0;
                while (v145 < 68) {
                    MEM[v145 + MEM[64]] = MEM[v145 + (MEM[64] + 32)];
                    v145 += 32;
                }
                if (v145 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x1983B0x5b9;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v147 = v148 = address(msg.data[varg3.data + msg.data[varg3.data] + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v149 = v150 = 96;
                } else {
                    v149 = v151 = MEM[64];
                    MEM[64] = v151 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v151] = RETURNDATASIZE();
                    RETURNDATACOPY(v151 + 32, 0, RETURNDATASIZE());
                }
                if (v148) {
                    v147 = v152 = !MEM[v149];
                    if (MEM[v149]) {
                        require(32 + v149 + MEM[v149] - (32 + v149) >= 32);
                        v147 = MEM[32 + v149];
                        require(v147 == bool(v147));
                    }
                }
                require(v147, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v137 += 1;
    }
}

function withdraw(address varg0, uint256 varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(msg.sender == _owner, Error('BBVault: ONLY_OWNER'));
    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {
        v0 = 0x24ed(this, varg0);
        require(varg1 <= v0, Error('BBVault: AmountExceed'));
        0x20f3(varg1, msg.sender, varg0);
        goto 0x49f1;
    } else {
        if (this.balance < varg1) {
            v1 = 0x24ed(this, 0x82af49447d8a07e3bd95bd0d56f35241523fbab1);
            v2 = _SafeSub(varg1, this.balance);
            require(v2 <= v1, Error('BBVault: AmountExceed'));
            require(bool((address(0x82af49447d8a07e3bd95bd0d56f35241523fbab1)).code.size));
            v3 = address(0x82af49447d8a07e3bd95bd0d56f35241523fbab1).withdraw(v2).gas(msg.gas);
            require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
        }
        v4 = msg.sender.call().value(varg1).gas(2300 * !varg1);
        require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    }
}

function VERSION() public nonPayable { 
    return 203;
}

function 0xf47(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { 
    CALLDATACOPY(v0.data, varg1, varg0);
    MEM[varg0 + v0.data] = 0;
    require(_refund == keccak256(v0.data), Error('BBVault: STATUS'));
    v1 = varg1 + varg0;
    require(v1 - varg1 >= 32);
    require(msg.data[varg1] <= 0xffffffffffffffff);
    v2 = varg1 + msg.data[varg1];
    require(v1 - v2 >= 288);
    v3 = MEM[64];
    require(!((v3 + 288 < v3) | (v3 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = v3 + 288;
    require(msg.data[v2] == address(msg.data[v2]));
    require(msg.data[v2 + 32] == address(msg.data[v2 + 32]));
    require(msg.data[v2 + 64] == address(msg.data[v2 + 64]));
    require(msg.data[v2 + 192] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 192] + 31 < v1);
    v4 = 0x3867(msg.data[v2 + msg.data[v2 + 192]]);
    require(!((MEM[64] + (~0x1f & v4 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v4 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v4 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 192]];
    v5 = v6 = MEM[64] + 32;
    v7 = v8 = v2 + msg.data[v2 + 192] + 32;
    require(v2 + msg.data[v2 + 192] + (msg.data[v2 + msg.data[v2 + 192]] << 5) + 32 <= v1);
    v9 = v10 = 0;
    while (v9 < msg.data[v2 + msg.data[v2 + 192]]) {
        MEM[v5] = msg.data[v7];
        v5 += 32;
        v7 += 32;
        v9 += 1;
    }
    require(msg.data[v2 + 224] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 224] + 31 < v1);
    v11 = 0x3867(msg.data[v2 + msg.data[v2 + 224]]);
    require(!((MEM[64] + (~0x1f & v11 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v11 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v11 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 224]];
    v12 = v13 = MEM[64] + 32;
    v14 = v15 = v2 + msg.data[v2 + 224] + 32;
    require(v2 + msg.data[v2 + 224] + (msg.data[v2 + msg.data[v2 + 224]] << 5) + 32 <= v1);
    v16 = v17 = 0;
    while (v16 < msg.data[v2 + msg.data[v2 + 224]]) {
        MEM[v12] = msg.data[v14];
        v12 += 32;
        v14 += 32;
        v16 += 1;
    }
    require(msg.data[v2 + 256] <= 0xffffffffffffffff);
    require(v2 + msg.data[v2 + 256] + 31 < v1);
    v18 = 0x388a(msg.data[v2 + msg.data[v2 + 256]]);
    require(!((MEM[64] + (~0x1f & v18 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v18 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v18 + 31);
    MEM[MEM[64]] = msg.data[v2 + msg.data[v2 + 256]];
    require(v2 + msg.data[v2 + 256] + msg.data[v2 + msg.data[v2 + 256]] + 32 <= v1);
    CALLDATACOPY(MEM[64] + 32, v2 + msg.data[v2 + 256] + 32, msg.data[v2 + msg.data[v2 + 256]]);
    MEM[32 + (MEM[64] + msg.data[v2 + msg.data[v2 + 256]])] = 0;
    if (!varg3) {
        require(msg.data[v2 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        varg3 = v19 = MEM[32 + (msg.data[v2 + 96] << 5) + MEM[64]];
    }
    v20 = _SafeAdd(varg3, varg2);
    require(msg.data[v2 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    MEM[(msg.data[v2 + 96] << 5) + MEM[64] + 32] = v20;
    while (v21 < MEM[MEM[64]]) {
        require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v22 = v23 = MEM[32 + (v21 << 5) + MEM[64]];
        if (0 != v23) {
            require(v21 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v24 = MEM[32 + (v21 << 5) + MEM[64]];
            if (uint8(bool(v24)) != 3) {
                v25 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v26) - MEM[64] + ~31);
                MEM[v25.data] = 32;
                MEM[v25.data + 32] = address(msg.data[v2]);
                MEM[v25.data + 64] = address(msg.data[v2 + 32]);
                MEM[v25.data + 96] = address(msg.data[v2 + 64]);
                MEM[v25.data + 128] = v21;
                MEM[v25.data + 160] = msg.data[v2 + 128];
                MEM[v25.data + 192] = msg.data[v2 + 160];
                MEM[v25.data + 224] = 288;
                MEM[v25.data + 320] = MEM[MEM[64]];
                v27 = v28 = v25.data + 320 + 32;
                v29 = v30 = MEM[64] + 32;
                v31 = v32 = 0;
                while (v31 < MEM[MEM[64]]) {
                    MEM[v27] = MEM[v29];
                    v27 += 32;
                    v29 += 32;
                    v31 += 1;
                }
                MEM[v25.data + 256] = v27 - v25.data + ~31;
                MEM[v27] = MEM[MEM[64]];
                v26 = v33 = v27 + 32;
                v34 = v35 = MEM[64] + 32;
                v36 = v37 = 0;
                while (v36 < MEM[MEM[64]]) {
                    MEM[v26] = MEM[v34];
                    v26 += 32;
                    v34 += 32;
                    v36 += 1;
                }
                MEM[v25.data + 288] = ~31 + (v26 - v25.data);
                MEM[v26] = MEM[MEM[64]];
                v38 = v39 = 0;
                while (v38 < MEM[MEM[64]]) {
                    MEM[v38 + (v26 + 32)] = MEM[v38 + (MEM[64] + 32)];
                    v38 += 32;
                }
                if (v38 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x24d00x2437B0xf47;
                } else {
                    MEM[MEM[MEM[64]] + (v26 + 32)] = 0;
                }
                v40 = v25.length;
                v41 = v25.data;
                _refund = keccak256(v25);
                if (bool(v24) != 4) {
                    if (bool(v24) != 9) {
                        if (bool(v24) != 10) {
                            v42 = v43 = bool(v24) == 5;
                            if (bool(v24) != 5) {
                                v42 = v44 = bool(v24) == 7;
                            }
                            if (!v42) {
                                v42 = bool(v24) == 11;
                            }
                            if (!v42) {
                                if (bool(v24) != 12) {
                                    if (bool(v24) != 2) {
                                        if (bool(v24) != 6) {
                                            if (bool(v24) != 8) {
                                                require(bool(v24) == 1, Error('BBVault: TYPE'));
                                                v22 = 0;
                                                v45 = address(v24 >> 24);
                                                v46 = new array[](v25.length);
                                                v47 = v48 = 0;
                                                while (v47 < v25.length) {
                                                    MEM[v47 + v46.data] = MEM[v47 + v25.data];
                                                    v47 += 32;
                                                }
                                                if (v47 <= v25.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x24d00x2437B0xf47;
                                                } else {
                                                    MEM[v25.length + v46.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x24d00x2437B0xf47;
                                            } else {
                                                v49 = v50 = address(v24 >> 24);
                                                v51 = new array[](v23);
                                                v52 = new array[](160);
                                                v53 = new array[](v25.length);
                                                v54 = v55 = 0;
                                                while (v54 < v25.length) {
                                                    MEM[v54 + v53.data] = MEM[v54 + v25.data];
                                                    v54 += 32;
                                                }
                                                if (v54 <= v25.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x24d00x2437B0xf47;
                                                } else {
                                                    MEM[v25.length + v53.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x24d00x2437B0xf47;
                                            }
                                        } else {
                                            v56 = new array[](v25.length);
                                            v57 = v58 = 0;
                                            while (v57 < v25.length) {
                                                MEM[v57 + v56.data] = MEM[v57 + v25.data];
                                                v57 += 32;
                                            }
                                            if (v57 <= v25.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x24d00x2437B0xf47;
                                            } else {
                                                MEM[v25.length + v56.data] = 0;
                                            }
                                            require(bool((address(v24 >> 24)).code.size));
                                            v59, /* bool */ v60 = address(v24 >> 24).flashLoan(address(this), address(msg.data[v2 + 64]), v23, v56).gas(msg.gas);
                                            require(bool(v59), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v60 == bool(v60));
                                            require(v60, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x24d00x2437B0xf47;
                                        }
                                    } else {
                                        v22 = v61 = 0;
                                        v45 = v62 = address(v24 >> 24);
                                        v63 = new array[](v25.length);
                                        v64 = v65 = 0;
                                        while (v64 < v25.length) {
                                            MEM[v64 + v63.data] = MEM[v64 + v25.data];
                                            v64 += 32;
                                        }
                                        if (v64 <= v25.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x24d00x2437B0xf47;
                                        } else {
                                            MEM[v25.length + v63.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x24d00x2437B0xf47;
                                    }
                                } else {
                                    if (v24 & 0x10) {
                                        v22 = v66 = v23 << 128;
                                    }
                                    v49 = address(v24 >> 24);
                                    v67 = new array[](v25.length);
                                    v68 = v69 = 0;
                                    while (v68 < v25.length) {
                                        MEM[v68 + v67.data] = MEM[v68 + v25.data];
                                        v68 += 32;
                                    }
                                    if (v68 <= v25.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x24d00x2437B0xf47;
                                    } else {
                                        MEM[v25.length + v67.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x24d00x2437B0xf47;
                                }
                            } else {
                                v49 = v70 = address(v24 >> 24);
                                v71 = new array[](128);
                                v72 = new array[](v25.length);
                                v73 = v74 = 0;
                                while (v73 < v25.length) {
                                    MEM[v73 + v72.data] = MEM[v73 + v25.data];
                                    v73 += 32;
                                }
                                if (v73 <= v25.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x24d00x2437B0xf47;
                                } else {
                                    MEM[v25.length + v72.data] = 0;
                                }
                            }
                            require(bool(v49.code.size));
                            v75 = v49.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v22, address(msg.data[v2 + 64]), address(this), v71, v51, v67, v72, v52, v53).gas(msg.gas);
                            require(bool(v75), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x24d00x2437B0xf47;
                        } else {
                            v22 = v76 = 0;
                            v45 = v77 = address(v24 >> 24);
                            v78 = new array[](v25.length);
                            v79 = v80 = 0;
                            while (v79 < v25.length) {
                                MEM[v79 + v78.data] = MEM[v79 + v25.data];
                                v79 += 32;
                            }
                            if (v79 <= v25.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x24d00x2437B0xf47;
                            } else {
                                MEM[v25.length + v78.data] = 0;
                            }
                        }
                    } else {
                        v81 = new uint256[](1);
                        CALLDATACOPY(v81.data, msg.data.length, 32);
                        require(0 < v81.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v82 = v81.data;
                        v81[0] = address(msg.data[v2 + 64]);
                        v83 = new uint256[](1);
                        CALLDATACOPY(v83.data, msg.data.length, 32);
                        require(0 < v83.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v84 = v83.data;
                        v83[0] = v23;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v45 = v85 = address(v24 >> 24);
                        v86 = new uint256[](v81.length);
                        v87 = v88 = v86.data;
                        v89 = v90 = v81.data;
                        v91 = v92 = 0;
                        while (v91 < v81.length) {
                            MEM[v87] = address(MEM[v89]);
                            v87 += 32;
                            v89 += 32;
                            v91 += 1;
                        }
                        MEM[v87] = v83.length;
                        v93 = v94 = v87 + 32;
                        v95 = v96 = v83.data;
                        v97 = v98 = 0;
                        while (v97 < v83.length) {
                            MEM[v93] = MEM[v95];
                            v93 += 32;
                            v95 += 32;
                            v97 += 1;
                        }
                        MEM[v93] = v25.length;
                        v99 = v100 = 0;
                        while (v99 < v25.length) {
                            MEM[v99 + (v93 + 32)] = MEM[v99 + v25.data];
                            v99 += 32;
                        }
                        if (v99 <= v25.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x24d00x2437B0xf47;
                        } else {
                            MEM[v25.length + (v93 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x24d00x2437B0xf47;
                    }
                    require(bool(v45.code.size));
                    v101 = v45.call(v86, v78, v63, v46, v22, v22, address(this), address(this), v86, v78, v63, v46, 1, v22, v87 - (4 + MEM[64]), address(this), address(this), v86, v78, v63, v46, v102, address(msg.data[v2 + 64])).gas(msg.gas);
                    require(bool(v101), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v103 = new uint256[](1);
                    CALLDATACOPY(v103.data, msg.data.length, 32);
                    require(0 < v103.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v104 = v103.data;
                    v103[0] = address(msg.data[v2 + 64]);
                    v105 = new uint256[](1);
                    CALLDATACOPY(v105.data, msg.data.length, 32);
                    require(0 < v105.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v106 = v105.data;
                    v105[0] = v23;
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = new uint256[](v103.length);
                    v109 = v110 = v108.data;
                    v111 = v112 = v103.data;
                    v113 = v114 = 0;
                    while (v113 < v103.length) {
                        MEM[v109] = address(MEM[v111]);
                        v109 += 32;
                        v111 += 32;
                        v113 += 1;
                    }
                    v109 = new uint256[](v105.length);
                    v115 = v116 = v109.data;
                    v117 = v118 = v105.data;
                    v119 = v120 = 0;
                    while (v119 < v105.length) {
                        MEM[v115] = MEM[v117];
                        v115 += 32;
                        v117 += 32;
                        v119 += 1;
                    }
                    v115 = new uint256[](v107.length);
                    v121 = v122 = v115.data;
                    v123 = v124 = v107.data;
                    v125 = v126 = 0;
                    while (v125 < v107.length) {
                        MEM[v121] = MEM[v123];
                        v121 += 32;
                        v123 += 32;
                        v125 += 1;
                    }
                    v121 = new array[](v25.length);
                    v127 = v128 = 0;
                    while (v127 < v25.length) {
                        MEM[v127 + v121.data] = MEM[v127 + v25.data];
                        v127 += 32;
                    }
                    if (v127 <= v25.length) {
                        goto 0x3374B0x347fB0x6ddB0x24d00x2437B0xf47;
                    } else {
                        MEM[v25.length + v121.data] = 0;
                    }
                    require(bool((address(v24 >> 24)).code.size));
                    v129 = address(v24 >> 24).flashLoan(address(this), v108, v109, v115, address(this), v121, uint16(0), v102, address(msg.data[v2 + 64])).gas(msg.gas);
                    require(bool(v129), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x24d00x2437B0xf47;
                }
                goto 0x50090x2437B0xf47;
            } else {
                require(bool((address(v24 >> 24)).code.size));
                v130 = address(v24 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(msg.data[v2 + 64]), v23, this).gas(msg.gas);
                require(bool(v130), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v21 += 1;
    }
    if (msg.data[v2 + 128]) {
        0x20f3(msg.data[v2 + 128], msg.data[v2 + 32], msg.data[v2 + 64]);
    }
    v131 = v132 = 0;
    while (v131 < MEM[MEM[64]]) {
        require(v131 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v133 = v133 + MEM[32 + (v131 << 5) + MEM[64]];
        v131 += 1;
    }
    _refund = 'EXECUTION';
    v134 = new array[](MEM[MEM[64]]);
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        MEM[v135 + v134.data] = MEM[v135 + (MEM[64] + 32)];
        v135 += 32;
    }
    if (v135 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x24d00x2437B0xf47;
    } else {
        MEM[MEM[MEM[64]] + v134.data] = 0;
    }
    require(bool((address(msg.data[v2])).code.size));
    v137 = address(msg.data[v2]).call(0x7fe3ba8b, address(msg.data[v2 + 32]), v133, v134).gas(msg.gas);
    require(bool(v137), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v138 = v139 = 0;
    while (v138 < MEM[MEM[64]]) {
        require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v140 = v141 = MEM[32 + (v138 << 5) + MEM[64]];
        if (0 != v141) {
            require(v138 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v142 = v143 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v138 << 5) + MEM[64] + 32]) != 4) {
                v142 = bool(MEM[(v138 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v142) {
                if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v144 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v144), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v140 = MEM[MEM[64]];
                }
                if (v140) {
                    0x20f3(v140, MEM[(v138 << 5) + MEM[64] + 32] >> 24, msg.data[v2 + 64]);
                    if (bool(MEM[(v138 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v138 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v145 = address(MEM[(v138 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v145), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v141;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v138 << 5) + MEM[64] + 32] >> 24));
                v146 = v147 = 0;
                while (v146 < 68) {
                    MEM[v146 + MEM[64]] = MEM[v146 + (MEM[64] + 32)];
                    v146 += 32;
                }
                if (v146 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x24d00x2437B0xf47;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v148 = v149 = address(msg.data[v2 + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v150 = v151 = 96;
                } else {
                    v150 = v152 = MEM[64];
                    MEM[64] = v152 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v152] = RETURNDATASIZE();
                    RETURNDATACOPY(v152 + 32, 0, RETURNDATASIZE());
                }
                if (v149) {
                    v148 = v153 = !MEM[v150];
                    if (MEM[v150]) {
                        require(32 + v150 + MEM[v150] - (32 + v150) >= 32);
                        v148 = MEM[32 + v150];
                        require(v148 == bool(v148));
                    }
                }
                require(v148, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v138 += 1;
    }
    return ;
}

// Note: The function selector is not present in the original solidity code.
// However, we display it for the sake of completeness.

function __function_selector__(bytes4 function_selector, address varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { 
    MEM[64] = 128;
    if (msg.data.length < 4) {
        if (!msg.data.length) {
            ();
        }
    } else {
        v0 = function_selector >> 224;
        if (0x8da5cb5b > v0) {
            if (0x512b7351 > v0) {
                if (0x15afd409 == v0) {
                    settle(address,uint256);
                } else if (0x1faa6b87 == v0) {
                    0x1faa6b87();
                } else if (0x23e30c8b == v0) {
                    onFlashLoan(address,address,uint256,uint256,bytes);
                } else if (0x3e2af770 == v0) {
                    0x3e2af770();
                } else if (0x405b019d == v0) {
                    executeOperation(address,address,uint256,uint256,bytes);
                } else if (0x410085df == v0) {
                    refund(address,uint256);
                }
            } else if (0x61b9f8d0 > v0) {
                if (0x512b7351 == v0) {
                    0x512b7351();
                } else if (0x5224372c == v0) {
                    borrow(address,address,uint256);
                } else if (0x5dbacec5 == v0) {
                    0x5dbacec5();
                }
            } else if (0x61b9f8d0 == v0) {
                0x61b9f8d0();
            } else if (0x6568a279 == v0) {
                withdrawAll(address[]);
            } else if (0x6e0e14e3 == v0) {
                0x6e0e14e3();
            } else if (0x78c8cda7 == v0) {
                removeWhitelist(address);
            }
        } else {
            if (0xc3924ed6 > v0) {
                if (0x8da5cb5b == v0) {
                    owner();
                } else if (0x920f5c84 == v0) {
                    executeOperation(address[],uint256[],uint256[],address,bytes);
                } else if (0xa60b0d3c != v0) {
                    if (0xa6f9dae1 == v0) {
                        changeOwner(address);
                    } else if (0xad8add11 == v0) {
                        0xad8add11();
                    } else if (0xb39d9009 == v0) {
                        addWhitelist(address,uint256);
                    }
                }
            } else if (0xee872558 > v0) {
                if (0xc3924ed6 != v0) {
                    if (0xe9cbafb0 != v0) {
                        if (0xee33b7e2 == v0) {
                            0xee33b7e2();
                        }
                    }
                }
            } else if (0xee872558 == v0) {
                executeOperation(address,uint256,uint256,bytes);
            } else if (0xf04f2707 == v0) {
                receiveFlashLoan(address[],uint256[],uint256[],bytes);
            } else if (0xf3fef3a3 == v0) {
                withdraw(address,uint256);
            } else if (0xffa1ad74 == v0) {
                VERSION();
            }
            0xa60b0d3c();
        }
    }
    require(!msg.value);
    require(4 <= msg.data.length);
    require(msg.data.length <= msg.data.length);
    require(4 + (msg.data.length - 4) - 4 >= 128);
    require(varg1 == varg1);
    require(varg4 <= 0xffffffffffffffff);
    require(4 + varg4 + 31 < 4 + (msg.data.length - 4));
    v1 = 0x388a(varg4.length);
    v2 = new bytes[](varg4.length);
    require(!((v2 + (~0x1f & v1 + 31) < v2) | (v2 + (~0x1f & v1 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    require(4 + varg4 + varg4.length + 32 <= 4 + (msg.data.length - 4));
    CALLDATACOPY(v2.data, varg4.data, varg4.length);
    v2[varg4.length] = 0;
    v3 = v2.length;
    v4 = v2.data;
    require(_refund == keccak256(v2), Error('BBVault: STATUS'));
    require(v2.data + v2.length - v2.data >= 32);
    require(MEM[v2.data] <= 0xffffffffffffffff);
    v5 = v2.data + MEM[v2.data];
    require(v2.data + v2.length - v5 >= 288);
    v6 = MEM[64];
    require(!((v6 + 288 < v6) | (v6 + 288 > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    require(v2[MEM[v2.data]] == address(v2[MEM[v2.data]]));
    require(MEM[v5 + 32] == address(MEM[v5 + 32]));
    require(MEM[v5 + 64] == address(MEM[v5 + 64]));
    require(MEM[v5 + 192] <= 0xffffffffffffffff);
    require(v5 + MEM[v5 + 192] + 31 < v2.data + v2.length);
    v7 = 0x3867(MEM[v5 + MEM[v5 + 192]]);
    require(!((MEM[64] + (~0x1f & v7 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v7 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v7 + 31);
    MEM[MEM[64]] = MEM[v5 + MEM[v5 + 192]];
    v8 = v9 = MEM[64] + 32;
    v10 = v11 = v5 + MEM[v5 + 192] + 32;
    require(v5 + MEM[v5 + 192] + (MEM[v5 + MEM[v5 + 192]] << 5) + 32 <= v2.data + v2.length);
    v12 = v13 = 0;
    while (v12 < MEM[v5 + MEM[v5 + 192]]) {
        MEM[v8] = MEM[v10];
        v8 += 32;
        v10 += 32;
        v12 += 1;
    }
    require(MEM[v5 + 224] <= 0xffffffffffffffff);
    require(v5 + MEM[v5 + 224] + 31 < v2.data + v2.length);
    v14 = 0x3867(MEM[v5 + MEM[v5 + 224]]);
    require(!((MEM[64] + (~0x1f & v14 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v14 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v14 + 31);
    MEM[MEM[64]] = MEM[v5 + MEM[v5 + 224]];
    v15 = v16 = MEM[64] + 32;
    v17 = v18 = v5 + MEM[v5 + 224] + 32;
    require(v5 + MEM[v5 + 224] + (MEM[v5 + MEM[v5 + 224]] << 5) + 32 <= v2.data + v2.length);
    v19 = v20 = 0;
    while (v19 < MEM[v5 + MEM[v5 + 224]]) {
        MEM[v15] = MEM[v17];
        v15 += 32;
        v17 += 32;
        v19 += 1;
    }
    require(MEM[v5 + 256] <= 0xffffffffffffffff);
    require(v5 + MEM[v5 + 256] + 31 < v2.data + v2.length);
    v21 = 0x388a(MEM[v5 + MEM[v5 + 256]]);
    require(!((MEM[64] + (~0x1f & v21 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v21 + 31) > 0xffffffffffffffff)), Panic(65)); // failed memory allocation (too much memory)
    MEM[64] = MEM[64] + (~0x1f & v21 + 31);
    MEM[MEM[64]] = MEM[v5 + MEM[v5 + 256]];
    require(v5 + MEM[v5 + 256] + MEM[v5 + MEM[v5 + 256]] + 32 <= v2.data + v2.length);
    v22 = v23 = 0;
    while (v22 < MEM[v5 + MEM[v5 + 256]]) {
        MEM[v22 + (MEM[64] + 32)] = MEM[v22 + (v5 + MEM[v5 + 256] + 32)];
        v22 += 32;
    }
    if (v22 <= MEM[v5 + MEM[v5 + 256]]) {
        goto 0x2ae3B0x3271;
    } else {
        MEM[MEM[v5 + MEM[v5 + 256]] + (MEM[64] + 32)] = 0;
    }
    require(MEM[v5 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    if (uint8(bool(MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]])) == 1) {
        v24 = _SafeAdd(0xf4240, uint16(MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]] >> 8));
        require(MEM[v5 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        require(!(bool(MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]]) & (v24 > ~0 / MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]])), Panic(17)); // arithmetic overflow or underflow
        require(0xf4240, Panic(18)); // division by zero
        require(MEM[v5 + 96] < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]] = MEM[32 + (MEM[v5 + 96] << 5) + MEM[64]] * v24 / 0xf4240;
    }
    while (v25 < MEM[MEM[64]]) {
        require(v25 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v26 = v27 = MEM[32 + (v25 << 5) + MEM[64]];
        if (0 != v27) {
            require(v25 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v28 = MEM[32 + (v25 << 5) + MEM[64]];
            if (uint8(bool(v28)) != 3) {
                v29 = new array[](32 + ((~0x1f & 31 + MEM[MEM[64]]) + v30) - MEM[64] + ~31);
                MEM[v29.data] = 32;
                MEM[v29.data + 32] = address(v2[MEM[v2.data]]);
                MEM[v29.data + 64] = address(MEM[v5 + 32]);
                MEM[v29.data + 96] = address(MEM[v5 + 64]);
                MEM[v29.data + 128] = v25;
                MEM[v29.data + 160] = MEM[v5 + 128];
                MEM[v29.data + 192] = MEM[v5 + 160];
                MEM[v29.data + 224] = 288;
                MEM[v29.data + 320] = MEM[MEM[64]];
                v31 = v32 = v29.data + 320 + 32;
                v33 = v34 = MEM[64] + 32;
                v35 = v36 = 0;
                while (v35 < MEM[MEM[64]]) {
                    MEM[v31] = MEM[v33];
                    v31 += 32;
                    v33 += 32;
                    v35 += 1;
                }
                MEM[v29.data + 256] = v31 - v29.data + ~31;
                MEM[v31] = MEM[MEM[64]];
                v30 = v37 = v31 + 32;
                v38 = v39 = MEM[64] + 32;
                v40 = v41 = 0;
                while (v40 < MEM[MEM[64]]) {
                    MEM[v30] = MEM[v38];
                    v30 += 32;
                    v38 += 32;
                    v40 += 1;
                }
                MEM[v29.data + 288] = ~31 + (v30 - v29.data);
                MEM[v30] = MEM[MEM[64]];
                v42 = v43 = 0;
                while (v42 < MEM[MEM[64]]) {
                    MEM[v42 + (v30 + 32)] = MEM[v42 + (MEM[64] + 32)];
                    v42 += 32;
                }
                if (v42 <= MEM[MEM[64]]) {
                    goto 0x3374B0x3766B0x1b5aB0x6ddB0x2af;
                } else {
                    MEM[MEM[MEM[64]] + (v30 + 32)] = 0;
                }
                v44 = v29.length;
                v45 = v29.data;
                _refund = keccak256(v29);
                if (bool(v28) != 4) {
                    if (bool(v28) != 9) {
                        if (bool(v28) != 10) {
                            v46 = v47 = bool(v28) == 5;
                            if (bool(v28) != 5) {
                                v46 = v48 = bool(v28) == 7;
                            }
                            if (!v46) {
                                v46 = bool(v28) == 11;
                            }
                            if (!v46) {
                                if (bool(v28) != 12) {
                                    if (bool(v28) != 2) {
                                        if (bool(v28) != 6) {
                                            if (bool(v28) != 8) {
                                                require(bool(v28) == 1, Error('BBVault: TYPE'));
                                                v26 = 0;
                                                v49 = address(v28 >> 24);
                                                v50 = new array[](v29.length);
                                                v51 = v52 = 0;
                                                while (v51 < v29.length) {
                                                    MEM[v51 + v50.data] = MEM[v51 + v29.data];
                                                    v51 += 32;
                                                }
                                                if (v51 <= v29.length) {
                                                    goto 0x3374B0x3782B0x2089B0x6ddB0x2af;
                                                } else {
                                                    MEM[v29.length + v50.data] = 0;
                                                }
                                                goto 0x1db9B0x6ddB0x2af;
                                            } else {
                                                v53 = v54 = address(v28 >> 24);
                                                v55 = new array[](v27);
                                                v56 = new array[](160);
                                                v57 = new array[](v29.length);
                                                v58 = v59 = 0;
                                                while (v58 < v29.length) {
                                                    MEM[v58 + v57.data] = MEM[v58 + v29.data];
                                                    v58 += 32;
                                                }
                                                if (v58 <= v29.length) {
                                                    goto 0x3374B0x33b4B0x203bB0x6ddB0x2af;
                                                } else {
                                                    MEM[v29.length + v57.data] = 0;
                                                }
                                                goto 0x1e8fB0x6ddB0x2af;
                                            }
                                        } else {
                                            v60 = new array[](v29.length);
                                            v61 = v62 = 0;
                                            while (v61 < v29.length) {
                                                MEM[v61 + v60.data] = MEM[v61 + v29.data];
                                                v61 += 32;
                                            }
                                            if (v61 <= v29.length) {
                                                goto 0x3374B0x33faB0x1f63B0x6ddB0x2af;
                                            } else {
                                                MEM[v29.length + v60.data] = 0;
                                            }
                                            require(bool((address(v28 >> 24)).code.size));
                                            v63, /* bool */ v64 = address(v28 >> 24).flashLoan(address(this), address(MEM[v5 + 64]), v27, v60).gas(msg.gas);
                                            require(bool(v63), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                                            require(v64 == bool(v64));
                                            require(v64, Error('Vault: ERC3156_FALSE'));
                                            goto 0x4a12B0x2af;
                                        }
                                    } else {
                                        v26 = v65 = 0;
                                        v49 = v66 = address(v28 >> 24);
                                        v67 = new array[](v29.length);
                                        v68 = v69 = 0;
                                        while (v68 < v29.length) {
                                            MEM[v68 + v67.data] = MEM[v68 + v29.data];
                                            v68 += 32;
                                        }
                                        if (v68 <= v29.length) {
                                            goto 0x3374B0x3782B0x1f27B0x6ddB0x2af;
                                        } else {
                                            MEM[v29.length + v67.data] = 0;
                                        }
                                        goto 0x1db9B0x6ddB0x2af;
                                    }
                                } else {
                                    if (v28 & 0x10) {
                                        v26 = v70 = v27 << 128;
                                    }
                                    v53 = address(v28 >> 24);
                                    v71 = new array[](v29.length);
                                    v72 = v73 = 0;
                                    while (v72 < v29.length) {
                                        MEM[v72 + v71.data] = MEM[v72 + v29.data];
                                        v72 += 32;
                                    }
                                    if (v72 <= v29.length) {
                                        goto 0x3374B0x34ffB0x1ee0B0x6ddB0x2af;
                                    } else {
                                        MEM[v29.length + v71.data] = 0;
                                    }
                                    goto 0x1e8fB0x6ddB0x2af;
                                }
                            } else {
                                v53 = v74 = address(v28 >> 24);
                                v75 = new array[](128);
                                v76 = new array[](v29.length);
                                v77 = v78 = 0;
                                while (v77 < v29.length) {
                                    MEM[v77 + v76.data] = MEM[v77 + v29.data];
                                    v77 += 32;
                                }
                                if (v77 <= v29.length) {
                                    goto 0x3374B0x33faB0x1e5bB0x6ddB0x2af;
                                } else {
                                    MEM[v29.length + v76.data] = 0;
                                }
                            }
                            require(bool(v53.code.size));
                            v79 = v53.flashLoan(0xf1676d37, 0xea3446bf, address(this), address(this), address(this), v26, address(MEM[v5 + 64]), address(this), v75, v55, v71, v76, v56, v57).gas(msg.gas);
                            require(bool(v79), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                            goto 0x4a12B0x2af;
                        } else {
                            v26 = v80 = 0;
                            v49 = v81 = address(v28 >> 24);
                            v82 = new array[](v29.length);
                            v83 = v84 = 0;
                            while (v83 < v29.length) {
                                MEM[v83 + v82.data] = MEM[v83 + v29.data];
                                v83 += 32;
                            }
                            if (v83 <= v29.length) {
                                goto 0x3374B0x356eB0x1e09B0x6ddB0x2af;
                            } else {
                                MEM[v29.length + v82.data] = 0;
                            }
                        }
                    } else {
                        v85 = new uint256[](1);
                        CALLDATACOPY(v85.data, msg.data.length, 32);
                        require(0 < v85.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v86 = v85.data;
                        v85[0] = address(MEM[v5 + 64]);
                        v87 = new uint256[](1);
                        CALLDATACOPY(v87.data, msg.data.length, 32);
                        require(0 < v87.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                        v88 = v87.data;
                        v87[0] = v27;
                        MEM[MEM[64]] = 0x5c38449e00000000000000000000000000000000000000000000000000000000;
                        v49 = v89 = address(v28 >> 24);
                        v90 = new uint256[](v85.length);
                        v91 = v92 = v90.data;
                        v93 = v94 = v85.data;
                        v95 = v96 = 0;
                        while (v95 < v85.length) {
                            MEM[v91] = address(MEM[v93]);
                            v91 += 32;
                            v93 += 32;
                            v95 += 1;
                        }
                        MEM[v91] = v87.length;
                        v97 = v98 = v91 + 32;
                        v99 = v100 = v87.data;
                        v101 = v102 = 0;
                        while (v101 < v87.length) {
                            MEM[v97] = MEM[v99];
                            v97 += 32;
                            v99 += 32;
                            v101 += 1;
                        }
                        MEM[v97] = v29.length;
                        v103 = v104 = 0;
                        while (v103 < v29.length) {
                            MEM[v103 + (v97 + 32)] = MEM[v103 + v29.data];
                            v103 += 32;
                        }
                        if (v103 <= v29.length) {
                            goto 0x3374B0x34ebB0x1d7cB0x6ddB0x2af;
                        } else {
                            MEM[v29.length + (v97 + 32)] = 0;
                        }
                        goto 0x1db9B0x6ddB0x2af;
                    }
                    require(bool(v49.code.size));
                    v105 = v49.call(v90, v82, v67, v50, v26, v26, address(this), address(this), v90, v82, v67, v50, 1, v26, v91 - (4 + MEM[64]), address(this), address(this), v90, v82, v67, v50, v106, address(MEM[v5 + 64])).gas(msg.gas);
                    require(bool(v105), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                } else {
                    v107 = new uint256[](1);
                    CALLDATACOPY(v107.data, msg.data.length, 32);
                    require(0 < v107.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v108 = v107.data;
                    v107[0] = address(MEM[v5 + 64]);
                    v109 = new uint256[](1);
                    CALLDATACOPY(v109.data, msg.data.length, 32);
                    require(0 < v109.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v110 = v109.data;
                    v109[0] = v27;
                    CALLDATACOPY(v111.data, msg.data.length, 32);
                    require(0 < v111.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
                    v112 = new uint256[](v107.length);
                    v113 = v114 = v112.data;
                    v115 = v116 = v107.data;
                    v117 = v118 = 0;
                    while (v117 < v107.length) {
                        MEM[v113] = address(MEM[v115]);
                        v113 += 32;
                        v115 += 32;
                        v117 += 1;
                    }
                    v113 = new uint256[](v109.length);
                    v119 = v120 = v113.data;
                    v121 = v122 = v109.data;
                    v123 = v124 = 0;
                    while (v123 < v109.length) {
                        MEM[v119] = MEM[v121];
                        v119 += 32;
                        v121 += 32;
                        v123 += 1;
                    }
                    v119 = new uint256[](v111.length);
                    v125 = v126 = v119.data;
                    v127 = v128 = v111.data;
                    v129 = v130 = 0;
                    while (v129 < v111.length) {
                        MEM[v125] = MEM[v127];
                        v125 += 32;
                        v127 += 32;
                        v129 += 1;
                    }
                    v125 = new array[](v29.length);
                    v131 = v132 = 0;
                    while (v131 < v29.length) {
                        MEM[v131 + v125.data] = MEM[v131 + v29.data];
                        v131 += 32;
                    }
                    if (v131 <= v29.length) {
                        goto 0x3374B0x347fB0x6ddB0x2af;
                    } else {
                        MEM[v29.length + v125.data] = 0;
                    }
                    require(bool((address(v28 >> 24)).code.size));
                    v133 = address(v28 >> 24).flashLoan(address(this), v112, v113, v119, address(this), v125, uint16(0), v106, address(MEM[v5 + 64])).gas(msg.gas);
                    require(bool(v133), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    goto 0x4a12B0x2af;
                }
                goto 0x2c1;
            } else {
                require(bool((address(v28 >> 24)).code.size));
                v134 = address(v28 >> 24).call(0xb13f0de800000000000000000000000000000000000000000000000000000000, address(MEM[v5 + 64]), v27, this).gas(msg.gas);
                require(bool(v134), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            }
        }
        v25 += 1;
    }
    if (MEM[v5 + 128]) {
        0x20f3(MEM[v5 + 128], MEM[v5 + 32], MEM[v5 + 64]);
    }
    v135 = v136 = 0;
    while (v135 < MEM[MEM[64]]) {
        require(v135 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v137 = v137 + MEM[32 + (v135 << 5) + MEM[64]];
        v135 += 1;
    }
    _refund = 'EXECUTION';
    v138 = new array[](MEM[MEM[64]]);
    v139 = v140 = 0;
    while (v139 < MEM[MEM[64]]) {
        MEM[v139 + v138.data] = MEM[v139 + (MEM[64] + 32)];
        v139 += 32;
    }
    if (v139 <= MEM[MEM[64]]) {
        goto 0x3374B0x34ffB0x75bB0x2af;
    } else {
        MEM[MEM[MEM[64]] + v138.data] = 0;
    }
    require(bool((address(v2[MEM[v2.data]])).code.size));
    v141 = address(v2[MEM[v2.data]]).call(0x7fe3ba8b, address(MEM[v5 + 32]), v137, v138).gas(msg.gas);
    require(bool(v141), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    v142 = v143 = 0;
    while (v142 < MEM[MEM[64]]) {
        require(v142 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
        v144 = v145 = MEM[32 + (v142 << 5) + MEM[64]];
        if (0 != v145) {
            require(v142 < MEM[MEM[64]], Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
            v146 = v147 = bool(MEM[(v142 << 5) + MEM[64] + 32]) == 4;
            if (bool(MEM[(v142 << 5) + MEM[64] + 32]) != 4) {
                v146 = bool(MEM[(v142 << 5) + MEM[64] + 32]) == 6;
            }
            if (!v146) {
                if (bool(MEM[(v142 << 5) + MEM[64] + 32]) == 3) {
                    require(bool((address(MEM[(v142 << 5) + MEM[64] + 32] >> 24)).code.size));
                    v148 = address(MEM[(v142 << 5) + MEM[64] + 32] >> 24).refundAmount().gas(msg.gas);
                    require(bool(v148), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
                    v144 = MEM[MEM[64]];
                }
                if (v144) {
                    0x20f3(v144, MEM[(v142 << 5) + MEM[64] + 32] >> 24, MEM[v5 + 64]);
                    if (bool(MEM[(v142 << 5) + MEM[64] + 32]) == 3) {
                        require(bool((address(MEM[(v142 << 5) + MEM[64] + 32] >> 24)).code.size));
                        v149 = address(MEM[(v142 << 5) + MEM[64] + 32] >> 24).refund().gas(msg.gas);
                        require(bool(v149), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
                    }
                }
            } else {
                MEM[MEM[64] + 68] = v145;
                MEM[MEM[64] + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 | uint224(address(MEM[(v142 << 5) + MEM[64] + 32] >> 24));
                v150 = v151 = 0;
                while (v150 < 68) {
                    MEM[v150 + MEM[64]] = MEM[v150 + (MEM[64] + 32)];
                    v150 += 32;
                }
                if (v150 <= 68) {
                    goto 0x33aa0x3398B0x2207B0x853B0x2af;
                } else {
                    MEM[68 + MEM[64]] = 0;
                }
                v152 = v153 = address(MEM[v5 + 64]).call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 0]).gas(msg.gas);
                if (RETURNDATASIZE() == 0) {
                    v154 = v155 = 96;
                } else {
                    v154 = v156 = MEM[64];
                    MEM[64] = v156 + (RETURNDATASIZE() + 63 & ~0x1f);
                    MEM[v156] = RETURNDATASIZE();
                    RETURNDATACOPY(v156 + 32, 0, RETURNDATASIZE());
                }
                if (v153) {
                    v152 = v157 = !MEM[v154];
                    if (MEM[v154]) {
                        require(32 + v154 + MEM[v154] - (32 + v154) >= 32);
                        v152 = MEM[32 + v154];
                        require(v152 == bool(v152));
                    }
                }
                require(v152, Error('BBVault: APPROVE_FAILED'));
            }
        }
        v142 += 1;
    }
}
